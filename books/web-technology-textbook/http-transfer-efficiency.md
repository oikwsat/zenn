---
title: "転送効率を上げる仕組み"
---

## HTTP/1.0 までのリクエストとレスポンス

HTTP/1.0 では、リクエスト・レスポンスのやり取りを行うたびに、TCP コメクションの接続・切断が行われていた。
![](https://storage.googleapis.com/zenn-user-upload/e4f5a2713208-20230811.png)

TCP コネクションの接続や切断がひんぱんに行われると、Web サーバーやネットワークに対して大きな負担がかかる。
10 クライアントから同時にリクエストを受け付けると、「10 クライアント × 　 100 リクエスト = 1,000 コネクション」が発生し、サーバにかかる負担が増大する。

## HTTP キープアライブ

HTTP/1.1 では、**持続接続**に対応した。
持続接続では、１つの TCP コネクションを使い回して１回目のリクエスト・レスポンスで使用したものを２回目以降も再利用する。

HTTP の持続接続機能を**HTTP キープアライブ**と呼ぶ。
![](https://storage.googleapis.com/zenn-user-upload/099988999cb6-20230811.png)

## パイプライン処理

クライアントがレスポンスを待たずに続けてリクエストを送信する処理のこと。
![](https://storage.googleapis.com/zenn-user-upload/f2acca388e49-20230811.png)

## 圧縮転送

コンテンツを圧縮してサイズを小さくしてから転送すること。
ネットワークにかかる負担を抑え、大量のデータ転送を可能にする。

**圧縮転送の流れ**

1. リクエスト時に、 `AcceptEncoding:` ヘッダーでクライアントが対応する圧縮方式をサーバーに通知する
2. レスポンス時に `ContentEncoding:`ヘッダーで実際に使用した圧縮方式が記述し、ボディに圧縮したデータを埋め込む
3. クライアントはレスポンスを受け取り、ボディを解答してリソースを取り出す

![](https://storage.googleapis.com/zenn-user-upload/8d34e34e84ca-20230811.png)

![](https://storage.googleapis.com/zenn-user-upload/065a2d1be990-20230811.png)

## 分割転送

サーバーからクライアントに大きなサイズのデータを転送する際、サーバーでデータを分割してから転送すること。
これによって、クライアントではデータ転送が完了するのを待たずに、受信したデータから順番に処理できる。
![](https://storage.googleapis.com/zenn-user-upload/ee12048d5c2c-20230811.png)

**分割転送の流れ**

1. クライアントがリクエストを送信する
2. サーバがレスポンスに `TransferEncoding:chunked` ヘッダーを挿入し、分割したデータとそのデータサイズを含めて送信する
3. すべてのデータ転送が完了して付記されたデータサイズが「0」になることで、クライアント側はリソースの転送完了を検知できる

もし分割転送でなければ、全てのデータのダウンロードが完了するまでブラウザで表示できない。
しかし、分割転送であれば、分割データを受け取るたびにブラウザでの表示を更新できるため、UX 向上につながる。
