---
title: "自動テストとは何か？"
---

ただ手動テストを自動化する「テスト自動化」はアンチパターンである。
では、「自動テスト」は具体的にどのように行うのか？

## 自動テストは開発サイクルの中で行う

「テスト自動化」では「自動テスト」における以下のメリットを握りつぶしてしまう。

- 開発者がテストによるフィードバックを素早く受けられるため、リリースサイクルを短縮できる

何故か？
それは、開発サイクルの外側であるリリースサイクルで、リグレッションテストを行うからである。
![](https://storage.googleapis.com/zenn-user-upload/2f8c0323a94c-20240923.png)
単にリグレッションテストを自動化しても、バグを発見した際に再度開発サイクルにて戻る必要が出てくる。
リリースサイクルの中では、開発者がテストによるフィードバックを素早く受けられず、リリースサイクルは短縮されない。

### ローカル環境で実行する

- コードを変更したら、自動テストを**ローカル環境**で実行する
- すべてのテストケースがパスしたら、「何も壊れていない」ということが**開発環境で**分かる
- 「壊れていない」ことをすぐに検証できるため、リファクタリングもしやすくなる
- Pull Request する時点で、開発者は品質に自信を持った状態でいられる

### Pull Request 時、ステージング環境のデプロイ時にも実行する

CI ツールを用い、ローカル環境だけでなく、**様々なタイミングで継続的に**実行する。

1. **Pull Request 作成後**
   - CI によるチェックが完了した状態で main ブランチにマージできる
2. **マージ後**
   - main ブランチには複数人の変更が入るため、何かが壊れている事態も考えられる
   - CI によりここでもチェックしておく
3. **ステージング環境のデプロイ時**
   - 本番環境に近い環境でもテストする
   - このタイミングでしか実行できないテストも存在する

## 自動テストは「どう動くのか」を開発者に説明してくれる

自動テストは、バグを検知してくれるだけではない。
アプリケーションが「**どう動くのか**」を開発者に説明するドキュメントにもなる。

### 単体テストでの例

以下は、「消費税込みの金額を計算する」関数。
税抜きの値段 `price` と税率 `rate` を引数として受け取る。

```ts
calculateTax(price: number, rate: 0.1)
```

他の開発者が見た場合、以下のような疑問が挙がる。

- 0 以下の値段を渡すとどうなるか？
- マイナスの税率を渡すとどうなるか？
- 端数がでる場合はどうなるか？

単体テストがないと、以下のように手動で確認する必要がある。

```ts
> calculateTax(price:0, rate:0.1)

> InvalidArgumentError('price は 1 以上にしてください')


> calculateTax(price:0. rate:-0.1)

> InvalidArgumentError('rate は 0 または正の数にしてください')


> calculateTax(price:10, rate:0.5)

> 11 // 切り上げられている


> calculateTax(price:10, rate:0.4)

> 10 // 切り捨てられている、つまりこの関数は四捨五入
```

しかし、単体テストを記述すると、これがドキュメントとなる。

```ts
test('税込みの金額を返す') {
  assert(calculateTax(price:100, rate:10)).expect(110)
}

test('金額が 0 ならエラー') {
  assert(calculateTax(price:0, rate:0.1)).expect(InvalidArgumentError)
}

test('税率がマイナスならエラー') {
  assert(calculateTax(price:100, rate:-0.1)).expect(InvalidArgumentError)
}

test('端数は四捨五入される') {
  assert(calculateTax(price:10, rate:0.5)).equal(11)
  assert(calculateTax(price:10, rate:0.4)).equal(10)
}
```

### E2E テストでの例

E2E テストは、ある画面がどのように使われるかが、コードとして記述されている。
コードを読めば、**ユーザーの具体的なユースケース**を理解できる。

## 【アンチパターン】腐りやすい E2E テスト

### 開発サイクルの中で実行しない

何故アンチパターンか？
それは、「**アプリケーションの変更に対してテストが追従できなくなる**」から

開発サイクルの外、つまり、リリースサイクルの中で E2E テストを行うと、リリース直線までシステムの E2E レベルの振る舞いが変更されたかどうかがわからない。

E2E テストのコードが最新の振る舞いに追従しているかどうかも、リリースのタイミングでしか分からなくなる。

開発サイクルの中でも E2E テストが実行され、メンテナンスがされていれば、開発者は自身の変更がシステムレベルの振る舞いを変えていないこと（または、変えていること）をチェックした上で開発を進めることができる。

### 振る舞いをテストしない

何故アンチパターンか？
それは、**「頻繁なメンテナンスが必要になる**」から。

自動テストは、ソフトウェアの振る舞いをテストするもの。
内部構造をテストするものではない。

E2E テストにおいて、「振る舞いをテストしない」とはどういうことか？
以下のフォームの `<input type="submit" value="送信" />` を例に考える。

```html
<form>
  <input type="text" placeholder="名前" />
  <input type="text" placeholder="会社名" />
  <input type="number" placeholder="年齢" />
  <input type="submit" value="送信" />　
</form>
```

テストコードにて、以下はアンチパターン。

```ts
findElement('input[type="submit"]').click();
```

上記は壊れにくい。
`type="submit"` を削除したらテストは失敗する。

以下も若干アンチパターン。

```ts
findElement('input[value="送信"]');
```

実装が `button` タグになったらテストは失敗する。

理想は下記のように、「ボタン」という役割を持つコンポーネントのうち、「送信」ラベルを持つものを探索するコード。

```ts
findElement(role: button, label: "送信").click();
```

:::message
**内部構造ではなく、「振る舞い」に依存したテストコードを書くことで、変更に強くできる。**
そもそも、E2E テストはユーザーの「振る舞い」を検証するもの。
:::
