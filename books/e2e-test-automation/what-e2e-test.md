---
title: "E2Eテスト"
---

## E2E テストとは？

ユーザーの使用シナリオに基づいて、アプリケーションの開始から終了までの全プロセスをテストする手法です。

:::details 全プロセスをテストする？？

Web アプリケーションは、以下にある様々なモジュールを組み合わせて実装されています。

1. ライブラリが提供する関数
2. ロジックを担う関数
3. UI を表現する関数
4. Web API クライアント
5. API サーバー
6. DB サーバー
7. Web ブラウザ

E2E 自動テストは、1〜7 までを「ヘッドレスブラウザ」+「UI オートメーション」の組み合わせを中心に構成されたテスティングフレームワークを用いて、検証します。

:::

:::message alert

E2E テストの定義は人や組織、文脈によってバラバラです。
そのため、上記の説明が明確な定義ではないことをご了承ください 🙇‍♂️

:::

## 特徴

1. **使用するインターフェースはユーザーインターフェース**
   - システムとしてユーザーに提供するものをテストするため
   - Web ブラウザやモバイルデバイスなどが対象になる
2. **テストケースはユーザーストーリーが基になる**

   - ユーザーがその機能を用いて達成したいことをテストする
   - 技術的制約によってユーザーストーリー以外のものをテストすることもある

3. **テスト対象は完全に統合されたシステム全体**
   - 単体テスト・結合テストよりも高レベルなテスト
   - マイクロサービスアーキテクチャの場合、全てのサービスが揃った完全な状態での動作を確認する
4. **想定されるバグは、「ユーザーストーリーそのものの失敗」**
   - 「ログイン出来ない」
   - 「商品がカートに入らない」
   - 「画面遷移ができない」etc.

## メリット

ここでは、E2E テストを行うことによる利点を説明します。

### ① ユーザーストーリーそのものをテストできる

E2E テストの大きな特徴は、ユーザーストーリーをそのままテストできる点です。
これは他のテストレベルではほぼ不可能な、E2E テスト独自の強みです。

ユーザーインターフェースを通じて実際のユーザー操作を再現することで、ソフトウェアが本当にユーザーの期待通りに動作するかを確認できます。
これにより、「**ユーザーストーリーの失敗**」という最も深刻なバグを発見することができます。

E2E テストを適切に実施することで、プロダクト上のクリティカルな欠陥を避け、ユーザーの満足度を高めることができるのです。

### ② 幅広い用途に利用できる

単体テストや結合テストでは難しい、以下の検証を行うことができます。

1. **互換性の確認**
   E2E テストを使えば、様々なブラウザ、OS、デバイスでソフトウェアが正しく動作するかを効率的に確認できます。
   これを手動テストでやろうとすると、大きなコストが必要になります...
2. **「生きたドキュメント」として**
   E2E テストは、ソフトウェアの使い方や機能を示す「生きたドキュメント」として活用できます。テストコードを読むことで、システムの動作を理解できるのです。
   詳細な仕様書がない古いシステムや、急速に開発が進んでいるプロジェクトでは、E2E テストにより現在の仕様を可視化できます。
   さらに、ソフトウェアが変更されると自動的にテストが失敗するので、ドキュメントの更新忘れを防げます。
3. **システムの監視ツールとして**
   実際のユーザー操作を模したテストを定期的に実行することで、システムの健全性を常にチェックできます。
   新しい機能をリリースした直後など、システムの基本的な機能が正常に動作しているかを素早く確認したい場合にも有効です。

## デメリット

E2E テストはいいことばかりではありません。
ネガティブな面やリスクについても説明しておきます。

### ① 自動化の難度と複雑性が高い

E2E テストの大きなデメリットの一つは、自動化そのものに必要な作業が複雑で、思わぬ落とし穴にはまりやすいことです。

#### E2E テスト自動化に必要な要素

そもそも、E2E テストを自動実行するには、最低でも以下の要素が必要になります。

1. **テスト対象のシステム**
   - システム全体が統合された状態
   - 実ユーザーが利用するのと同等の環境が必要
2. **クライアント**
   - ブラウザやモバイルデバイスなど
   - 場合によってはリアルデバイスではなく、エミュレーターなどで代替することも
3. **オートメーションツール**
   - ユーザーインターフェースを自動操作するためのツール
   - ブラウザなどのクライアントソフトウェア自身が提供している場合や、サードパーティのツールを利用する場合がある

テストのために多くの要素が必要となり、単体テストや結合テストと比べてもかなり複雑です...

#### 自動化する上での課題

複数の要素を連携してテストするため、様々なことを考慮する必要があります。

1. **ツールのバグによる影響**
   - クライアントやオートメーションツールのバグに遭遇する可能性がある
   - 例：Google Chrome を自動操作するための ChromeDriver
2. **多様な環境への対応**
   - 新しいブラウザや多種多様なブラウザをテストしたいという要求がある
   - これらの環境自体が抱える問題により、自動テストがうまく動かないケースが発生する
3. **エミュレーターやシミュレーターの利用**
   - クライアントやモバイルデバイスのエミュレーター/シミュレーターを利用する場合、これらがトラブルを引き起こす可能性がある
4. **システム外部への依存**
   - E2E テストはシステムを外から利用してテストする
   - 他のテストレベルとは異なり、システムの外に大きく依存するテスト
   - 実装における考慮事項が非常に多くなる
5. **セキュリティ設定などの考慮**
   - 開発中のシステム特有のセキュリティ設定など、特別な考慮事項が存在する可能性がある

:::message
E2E テストは他のテストレベルとは異なり、**システムの外に大きく依存する**テストです。
そのため、実装における考慮事項は多くなります。
:::

![](https://storage.googleapis.com/zenn-user-upload/56a5276b8734-20240924.png =350x)

### ② テスタビリティへの配慮が難しい

E2E テストは、システム全体の「振る舞い」を検証する強力なツールですが、同時にテスタビリティに関して特有の課題を抱えています。

#### 内部状態の取得の難しさ

E2E テストは主にシステム全体の外部から観察可能な振る舞いに焦点を当てますが、特定の条件下での動作を検証するために、やむを得ずシステム内部の状態を取得する必要が生じる場合があります。
しかし、E2E テストにおいてこのような内部状態の取得を実装することは以下の懸念点があります。

- システムの内部構造に深く依存するテストコードを書く必要があり、保守性が低下する
- テスト用の特別なインターフェースや機能を追加する必要があり、本番環境との乖離が生じる可能性がある
- 内部状態の取得自体がシステムの挙動に影響を与え、テスト結果の信頼性を損なう可能性がある

この問題により、複雑な条件や状態遷移を伴うテストシナリオの実装は難しいのです...

#### モックとスタブの利用制限

単体テストや統合テストでは、モックやスタブを使用してテスト対象を分離し、特定の条件下での動作を検証することが一般的です。
しかし、E2E テストではこれらの技法の使用には以下の懸念点があります。

- 実際の環境での動作を検証するという E2E テストの本質的な目的と相反する
- システム全体の統合状態を正確に反映できなくなる可能性がある

外部のサードパーティ API を利用する場合を例にすると以下のようなトレードオフを考慮する必要があります。

1. **実際の API を使用する場合**
   - テストの信頼性が向上する
   - しかし、API の動作や可用性に依存してテストが不安定になる可能性がある
   - コストやレート制限の問題が発生する可能性がある
2. **API をモック化する場合**
   - テストの安定性と再現性が向上する
   - しかし、「完全に統合された状態のシステムのテスト」という E2E テストの本来の価値が損なわれる
   - 実際の環境で発生する可能性のある問題を見逃す危険性がある

### ③ 高コスト

E2E テストの実施にはコストがかかります。

1. **時間的なコスト**
   - 本物のブラウザやモバイルデバイスなどを利用するため、起動やページロードも含め、実行時間が長くなる
   - ログインが必要なシステムでは、テストケースの度にログイン処理が必要になり、実行時間が長くなる可能性がある
2. **金銭的なコスト**
   - 環境やデバイスの数に比例して金銭的コストが増加する
   - 完全に統合された状態でシステムを起動する必要があるため、場合によっては本番環境と同等の環境を準備する必要がある

## E2E テストの導入戦略

E2E テストによる恩恵は大きいですが、一方で導入ハードルはとても高いです。
では、どのようなことを考慮して E2E テストを導入していけばよいのでしょうか？

### ① 現状のテスト状況を把握する

テストには「単体テスト」「結合テスト」「E2E テスト」「手動テスト」等、複数のレベルが存在します。まずは、これらテストレベルのコスト配分が現状どのようになっているのかを把握する必要があります。

例えば、よく知られているベストプラクティスとして**テストピラミッド**があります。
これは、下層のテストが多くなるモデルで、安定した費用対効果の高いテスト戦略と言われています。

一方、真逆のバッドプラクティスとして**アイスクリームコーン**というものもよく知られています。
これは、極めて少ない量の自動テストと、大量の手動テストに依存した状態です。

![](https://storage.googleapis.com/zenn-user-upload/34579ee95405-20240926.png =600x)
_左: テストピラミッド、右: アイスクリームコーン
引用: https://codezine.jp/article/detail/19909_

\
他にも形態はありますが、大事なのは、**現状を把握する**ということです。

現状を知らなければ、何から始めれば良いのか？も分かりません。
闇雲に進めて...結局問題が解決しない...という事態に陥ってしまいます。

### ② 短期的な戦略と長期的な戦略を分けて考える

現状を把握した結果、テスト状況がアイスクリームコーンであったとしましょう。（テストに悩む多くの現場は、このケースが多いらしい...）
開発プロセスが大量の手動テストに依存してしまっているため、何とか改善したいです...
できればテストピラミッドの状態にしたいです。
![](https://storage.googleapis.com/zenn-user-upload/09f16ae92610-20240925.png)
_現状を変えたい....!_

\
しかし、いきなり変えるのは流石に難しいです...
ではどうするか？？

短期的な戦略と長期的な戦略を分け、以下のように段階的に進めていくのが得策です。
![](https://storage.googleapis.com/zenn-user-upload/b1ed508b2b46-20240925.png)
_少しずつ着実に改善する
引用: https://codezine.jp/article/detail/19909_

#### 短期的な戦略

まずは「手動テストが多い」という状況から脱却することを目指します。
そのための手段として、E2E テストを導入して自動化します。

手動テストは通常、実際のユーザーの行動を模倣して検証を行います。
E2E テストも同様に、ユーザーの視点からシステム全体の動作を確認するため、手動テストのシナリオを変換しやすいです。

![](https://storage.googleapis.com/zenn-user-upload/a1b05c441c41-20240927.png =400x)
_手動テストを自動化する
引用: https://codezine.jp/article/detail/19909_

\
これで、手動テストが多い現状から脱却し、開発プロセスが多少は改善するでしょう。

:::details そもそも自動テストが存在しない場合は？

テストを書いてこなかったプロジェクトに対して、E2E テストから始めるのは良い手段です。
\
アプリを実装したあと、ログインをしてみたり、画面のボタンをクリックしてみたり、フォームに入力して内容が反映されているか確認したり...といった、動作確認を行っていると思います。
その動作確認として行った操作をそのまま E2E テストとして、実装するのです。
**「自動テストが存在する」という状態を作ることが一番重要です。**
\
どれからテストすれば良いか迷った場合は、「この機能が動かないとシステムとして成り立たない」といったクリティカルなケースを対象にしましょう。

:::

しかし、E2E テストの比重が大きい状態が長く続くと問題になります。
何故問題か？
E2E テストのデメリットを思い出してください。

- 自動化の難度と複雑性が高い
- テスタビリティへの配慮が難しい
- 高コスト

E2E テストの数が多くなればなるほど、テスト実行時間が長くなり、メンテナンスが難しくなり、不安定な状態に陥ります。
プロダクトの品質は向上するかもしれませんが、開発生産性は減少してしまいます...
（やがて pass しないテストが出てきて、メンテナンスを維持できなくなり、品質を保てなくなるケースも...）

そのため、短期的な施策としては良いですが、どこかのタイミングでテストピラミッドに近づけるための施策を打つ必要があります。

:::details 何故、E2E テストの比重が大きくなってしまうのか？

よくある原因は、**開発チームと QA チームのサイロ化**です。
開発チームと QA チームの距離が遠い組織は多いのではないでしょうか？
\
分断されていると、**開発チームが単体テストの設計・実装を担当し、QA チームが E2E テストの設計・実装を行う**ケースが多いです。
何故なら、手動テストをしていたのは QA なので、自動化も QA がやる流れになります。
\
QA は自分たちの責務に対しベストを尽くそうとするため、結果として E2E テストの比重が多くなってしまうのです。

:::

#### 長期的な戦略

では、どのようにしてピラミッドにしていくのか？

それは、現状の E2E テストに対し「**結合テストや単体テストで代替できるものを見つける**」ことです。
上位層にあったテストを少しずつ下位層へと分解していくのです。
![](https://storage.googleapis.com/zenn-user-upload/31f228df4a10-20240927.png)
_引用: https://codezine.jp/article/detail/19909_

\
例えば、E2E テストから結合テストへの分解は、モックやスタブを利用することで可能になるかもしれません。

この時に重要なのが、**目的と技術的な制約を混同しない**ことです。
「内部構造の変化が多く、単体テストに不向き」「単体テストに習熟したメンバーがいない」などの理由で、仕方なく E2E テストになっているものと、「これは E2E で検証すべきだ」というものを区別して考えることで、分解がしやすくなるでしょう。

具体的にどう分解していくか？は[こちらの記事](https://logmi.jp/tech/articles/330973#s4)が参考になります。

## E2E テストコードを書くまでのステップ

E2E テストが何者か？はある程度理解できました。
しかしまだ、E2E テストに対して疑問点があります。

「**どうやってテストコード書いていけば良いんだ？？？？**」

このままでは、先輩に「E2E テストのコードを書いといて！」と言われても、何から始めれば良いのか分かりません。困ります...
何故なのでしょうか？

それは、「**何をどのようにテストすれば良いか？**」を定めていないかです。
具体的には以下の手順で進めます。

### ① ユーザーストーリーを定義する

ユーザーストーリーとは、ソフトウェアの機能や要件を**ユーザーの視点**から簡潔に記述したものです。

E2E テストにおいて、テストケースの基となるのはユーザーストーリーです。
そのため、まずはユーザーストーリーの定義から始めるのです。

:::details EC サイトの例
「既存ユーザーが EC サイトにログインし、商品を検索して購入する」
:::

### ② ユーザーストーリーをテストするための手順を定義する

ユーザーが実際にアプリケーションを使用する際の操作を順序立てて記述します。
「**テストシナリオ**」と読んだりもします。

:::details EC サイトの例

1. ログインページにアクセスする
2. ユーザー名とパスワードを入力する
3. ログインボタンをクリックする
4. ホームページが表示されることを確認する
5. 検索バーに商品名を入力する
6. 検索ボタンをクリックする
7. 検索結果ページが表示されることを確認する
8. 目的の商品をクリックする
9. 商品詳細ページが表示されることを確認する
10. 「カートに追加」ボタンをクリックする
11. カートページに遷移することを確認する
12. 「購入手続きへ」ボタンをクリックする
13. 配送先情報を入力する
14. 支払い方法を選択する
15. 「注文確定」ボタンをクリックする
16. 注文完了ページが表示されることを確認する

:::

### ③ テストシナリオに具体性を持たせる

② の時点で、もうテストコードを書き始められそうですが、まだ必要なことがあります。

例えば「ユーザー名とパスワードを入力する」とありますが、具体値は定めていません。
「商品名」や「目的の商品」などもそうです。

これではテスト可能な状態ではないので、より具体性を持たせます。

:::details EC サイトの例

1. ログインページにアクセスする
2. ユーザー名（`user@example.com`）とパスワード（`password123`）を入力する
3. ログインボタンをクリックする
4. ホームページが表示されることを確認する
5. 検索バーに商品名（`ワイヤレスイヤホン`）を入力する
6. 検索ボタンをクリックする
7. 検索結果ページが表示されることを確認する
8. 目的の商品（`Sony WF-1000XM4`）をクリックする
9. 商品詳細ページが表示されることを確認する
10. 「カートに追加」ボタンをクリックする
11. カートページに遷移することを確認する
12. 「購入手続きへ」ボタンをクリックする
13. 配送先情報（`東京都渋谷区テスト町 1-1-1`）を入力する
14. 支払い方法（`クレジットカード`、番号: `4111111111111111`、有効期限: `12/25`、セキュリティコード: `123`）を選択する
15. 「注文確定」ボタンをクリックする
16. 注文完了ページが表示されることを確認する

:::

### ④ テストコードを書く

さあ、これで準備は整いました！！
あとはテスティングフレームワークの使い方さえ分かれば、コードを書くのはそんなに難しくないはずです。

前述の EC サイトを例に、Playright でコードを記述してみます。

:::details テストコードはこちら

```ts
const { test, expect } = require("@playwright/test");

test("既存ユーザーが EC サイトにログインし、商品を検索して購入する", async ({
  page,
}) => {
  // 1. ログインページにアクセスする
  await page.goto("https://example-ec-site.com/login");

  // 2. ユーザー名とパスワードを入力する
  await page.fill("#email", "user@example.com");
  await page.fill("#password", "password123");

  // 3. ログインボタンをクリックする
  await page.click("#login-button");

  // 4. ホームページが表示されることを確認する
  await expect(page).toHaveURL("https://example-ec-site.com/home");
  await expect(page.locator(".user-greeting")).toContainText(
    "Welcome, user@example.com"
  );

  // 5. 検索バーに商品名を入力する
  await page.fill("#search-input", "ワイヤレスイヤホン");

  // 6. 検索ボタンをクリックする
  await page.click("#search-button");

  // 7. 検索結果ページが表示されることを確認する
  await expect(page).toHaveURL(
    "https://example-ec-site.com/search?q=ワイヤレスイヤホン"
  );
  await expect(page.locator(".search-results")).toBeVisible();

  // 8. 目的の商品をクリックする
  await page.click("text=Sony WF-1000XM4");

  // 9. 商品詳細ページが表示されることを確認する
  await expect(page).toHaveURL(/\/product\/sony-wf-1000xm4/);
  await expect(page.locator("h1")).toContainText("Sony WF-1000XM4");

  // 10. 「カートに追加」ボタンをクリックする
  await page.click("#add-to-cart-button");

  // 11. カートページに遷移することを確認する
  await expect(page).toHaveURL("https://example-ec-site.com/cart");
  await expect(page.locator(".cart-items")).toContainText("Sony WF-1000XM4");

  // 12. 「購入手続きへ」ボタンをクリックする
  await page.click("#proceed-to-checkout");

  // 13. 配送先情報を入力する
  await page.fill("#shipping-address", "東京都渋谷区テスト町 1-1-1");

  // 14. 支払い方法を選択する
  await page.selectOption("#payment-method", "credit-card");
  await page.fill("#card-number", "4111111111111111");
  await page.fill("#card-expiry", "12/25");
  await page.fill("#card-cvc", "123");

  // 15. 「注文確定」ボタンをクリックする
  await page.click("#place-order-button");

  // 16. 注文完了ページが表示されることを確認する
  await expect(page).toHaveURL(
    "https://example-ec-site.com/order-confirmation"
  );
  await expect(page.locator(".order-confirmation")).toContainText(
    "ご注文ありがとうございます"
  );
  await expect(page.locator(".order-details")).toContainText("Sony WF-1000XM4");
});
```

:::

## テストコードの設計方針

ここまででとりあえずテストコードを書き、テストを実施させることは出来ました。
続いては、ここでは、テストコードを書く際に意識すべき主要な設計方針について解説します。

プロダクトコードとは異なる考え方が必要な場面もあり、テスト特有の方針も存在します。

### 1. テストの独立性を保つ

テストは互いに独立して実行できるようにすることが基本です。
これには以下のような利点があります。

- 特定のテストだけを実行できる柔軟性
- テストの順序に依存しない安定性
- 問題の特定と修正が容易

Playwright などのフレームワークは、テストのスキップや特定テストの単独実行をサポートしています。
これらの機能を活用するためにも、各テストが他のテストの結果に依存しないように設計することが重要です。

### 2. テストは単独で読めるようにする

テストコードは、それぞれのテストケースが単独で理解できるように設計することが重要です。
以下の点に注意してテストコードを書きましょう。

1. **シンプルで直接的な構造を保つ**

   - テスティングフレームワークが提供する機能をそのまま使用する
   - 過度な抽象化や構造化を避ける
   - メッセージや検証内容を直接テストコードに記述する
   - 特定のフォームの検証をメソッド化するなど、テストコード自体の高度な構造化は避ける

2. **DRY の原則を適切に適用する**

   - 「ログイン」など、多くのテストで共通的に使われるロジック、準備コード、片付けコード以外の共通化は最小限に留める
   - テストの単独での読みやすさを優先し、多少の重複は許容する

3. **必要最小限の構造化**

   - 同じ準備ロジックや片付けの処理がある場合は、`test.describe()`, `test.beforeEach()`, `test.afterEach()`などを使用する
   - これらの機能は、関連するテストのグルーピング、準備コードの明確化、失敗時の確実な後処理実行などの付加価値がある
   - 構造化はこれらの機能で対応できる範囲にとどめる

4. **エラー時の修正しやすさを重視**
   - 各テストは独立して理解・修正できるようにする
   - 共通処理の変更が多くのテストに影響を与えるような設計は避ける

これらの方針に従うことで、テストコードの可読性が向上し、メンテナンスが容易になります。
また、新しくチームに加わったメンバーでも個々のテストの意図を理解しやすくなります。

### 3. 壊れにくいテストを目指す

E2E テストは環境の変化や小さな修正で失敗しやすい傾向があります。
以下のような点に注意して、壊れにくいテストを設計しましょう。

- より抽象度の高いセレクタを使用する（例：クラス名よりもロールベースのセレクタ）
- CSS や DOM 構造の変更に強いテストを書く
- 固定の待ち時間ではなく、Playwright のタイムアウト機能を適切に使用する

## 壊れにくいテストを作る

E2E に限らず、**自動テストにおいて信頼性の高い実行結果を保つことは重要です**。
「信頼性が高い実行結果」とは、「**アプリケーションの振る舞いが変わらない限り、テストの結果は変わらない**」ということです。

信頼性が高ければ、開発者は自動テストの結果を信じることができます。（当然ですね）
自動テストの結果を信じることができれば、自身の書いたプロダクトコードに対し、

- テスト成功 → リリースやデプロイ OK
- テスト失敗 → コードに直すべき場所がある

を開発工程で素早く判断することができます。

このような状態を作ってくれるのが自動テストの良さであるため、テストの結果を安定させ、信頼性を高めるようなテストを設計することは非常に重要なのです。

:::message

実行結果が不安定であり、信頼性が低いテストのことを「**Flaky Test**」と呼びます。
この用語は様々な記事や書籍で登場するので覚えておいたほうが良いでしょう。

:::

では、壊れにくく、信頼性を保ち続けられるような E2E テストを作るにはどうすれば良いのでしょうか？
主要な取り組みとして、以下が挙げられます。

- テストごとにデータを用意する
- 内部構造に依拠しない

### テストごとにテストデータを用意する

壊れにく

## テストコードの可読性を高める

次は、先ほどの EC サイトの例を例にしたテストコードの**可読性**を高める方法について解説していきます。

:::details 改善するテストコードはこちら

```ts
const { test, expect } = require("@playwright/test");

test("既存ユーザーが EC サイトにログインし、商品を検索して購入する", async ({
  page,
}) => {
  // 1. ログインページにアクセスする
  await page.goto("https://example-ec-site.com/login");

  // 2. ユーザー名とパスワードを入力する
  await page.fill("#email", "user@example.com");
  await page.fill("#password", "password123");

  // 3. ログインボタンをクリックする
  await page.click("#login-button");

  // 4. ホームページが表示されることを確認する
  await expect(page).toHaveURL("https://example-ec-site.com/home");
  await expect(page.locator(".user-greeting")).toContainText(
    "Welcome, user@example.com"
  );

  // 5. 検索バーに商品名を入力する
  await page.fill("#search-input", "ワイヤレスイヤホン");

  // 6. 検索ボタンをクリックする
  await page.click("#search-button");

  // 7. 検索結果ページが表示されることを確認する
  await expect(page).toHaveURL(
    "https://example-ec-site.com/search?q=ワイヤレスイヤホン"
  );
  await expect(page.locator(".search-results")).toBeVisible();

  // 8. 目的の商品をクリックする
  await page.click("text=Sony WF-1000XM4");

  // 9. 商品詳細ページが表示されることを確認する
  await expect(page).toHaveURL(/\/product\/sony-wf-1000xm4/);
  await expect(page.locator("h1")).toContainText("Sony WF-1000XM4");

  // 10. 「カートに追加」ボタンをクリックする
  await page.click("#add-to-cart-button");

  // 11. カートページに遷移することを確認する
  await expect(page).toHaveURL("https://example-ec-site.com/cart");
  await expect(page.locator(".cart-items")).toContainText("Sony WF-1000XM4");

  // 12. 「購入手続きへ」ボタンをクリックする
  await page.click("#proceed-to-checkout");

  // 13. 配送先情報を入力する
  await page.fill("#shipping-address", "東京都渋谷区テスト町 1-1-1");

  // 14. 支払い方法を選択する
  await page.selectOption("#payment-method", "credit-card");
  await page.fill("#card-number", "4111111111111111");
  await page.fill("#card-expiry", "12/25");
  await page.fill("#card-cvc", "123");

  // 15. 「注文確定」ボタンをクリックする
  await page.click("#place-order-button");

  // 16. 注文完了ページが表示されることを確認する
  await expect(page).toHaveURL(
    "https://example-ec-site.com/order-confirmation"
  );
  await expect(page.locator(".order-confirmation")).toContainText(
    "ご注文ありがとうございます"
  );
  await expect(page.locator(".order-details")).toContainText("Sony WF-1000XM4");
});
```

:::

現状には以下の点でまだ改善することが可能です。

- テストコードが**コメントに頼りすぎている**
- テストコードの中に**ユーザー目線でない**箇所が含まれている
- テストコードの随所に**暗黙の文脈**が見られる
- テストコードがテストしたいポイントに対して**長すぎる**

## 【アンチパターン】腐りやすい E2E テスト

### ① 開発サイクルの中で実行しない

何故アンチパターンか？
それは、「**アプリケーションの変更に対してテストが追従できなくなる**」から

開発サイクルの外、つまり、リリースサイクルの中で E2E テストを行うと、リリース直線までシステムの E2E レベルの振る舞いが変更されたかどうかがわからない。

E2E テストのコードが最新の振る舞いに追従しているかどうかも、リリースのタイミングでしか分からなくなる。

開発サイクルの中でも E2E テストが実行され、メンテナンスがされていれば、開発者は自身の変更がシステムレベルの振る舞いを変えていないこと（または、変えていること）をチェックした上で開発を進めることができる。

### ②「振る舞い」に依拠しないテストコード

何故アンチパターンか？
それは、**「頻繁なメンテナンスが必要になる**」からです。

E2E テストは、ユーザーの「**振る舞い**」をテストするものです。
内部構造をテストするものではありません。

「振る舞いをテストしない」とはどういうことか？
以下のフォームの `<input type="submit" value="送信" />` を例に考える。

```html
<form>
  <input type="text" placeholder="名前" />
  <input type="text" placeholder="会社名" />
  <input type="number" placeholder="年齢" />
  <input type="submit" value="送信" />　
</form>
```

テストコードにて、以下はアンチパターン。

```ts
findElement('input[type="submit"]').click();
```

上記は壊れにくい。
`type="submit"` を削除したらテストは失敗する。

以下も若干アンチパターン。

```ts
findElement('input[value="送信"]');
```

実装が `button` タグになったらテストは失敗する。

理想は下記のように、「ボタン」という役割を持つコンポーネントのうち、「送信」ラベルを持つものを探索するコード。

```ts
findElement(role: button, label: "送信").click();
```
