---
title: "SQLインジェクション"
---

## 概要

- SQL の呼び出し方に不備がある場合に発生する脆弱性
- アプリケーションに SQL インジェクション脆弱性がある場合、以下の影響を受ける可能性がある
  - DB 内のすべての情報が外部から盗まれる
  - DB の内容が書き換えられる
  - 認証を回避される（ID とパスワードを用いずにログインされる）
  - その他、DB サーバ上のファイル読み出し、書き込み、プログラムの実行などを行われる
- すべて、攻撃者が能動的に（利用者の関与なしで）サーバを攻撃できる
- SQL インジェクションの確実な対策は、静的プレースホルダを利用して SQL を呼び出すこと

![](https://storage.googleapis.com/zenn-user-upload/3383868f0029-20240111.png)

## 攻撃手法と影響

- 以下は `books` テーブルから `author` カラムが指定された著者名（`$author`）と一致する全ての書籍を選択する SQL
- 攻撃者は、`$author` の値を操ることで、SQL インジェクション攻撃を試みることができる

```sql
SELECT * FROM books WHERE author = '$author' ORDER BY id;
```

### エラーメッセージ経由の情報漏洩

`$author` に以下の値が注入されたとする。

```
' AND EXTRACTVALUE(0, (SELECT CONCAT(id, ':', password) FROM users LIMIT 0, 1));
```

この値を元のクエリに挿入すると、以下のようになる。

```sql
SELECT * FROM books WHERE author = '' AND EXTRACTVALUE(0, (SELECT CONCAT(id, ':', password) FROM users LIMIT 0, 1));' ORDER BY id;
```

クエリの内容は以下の通り。

1. **最初の `'` で文字列リテラルを閉じる**
   - これにより、元の `author` 条件が終了する
2. **`AND EXTRACTVALUE(...)`**
   - `EXTRACTVALUE` 関数が注入され、悪意のある操作が開始される
3. **`(SELECT CONCAT(id, ':', password) FROM users LIMIT 0, 1)`**
   - `users` テーブルから最初のユーザの `id` と `password` を連結して取得する
   - この結果は `EXTRACTVALUE` 関数に渡される
4. **`EXTRACTVALUE(0, ...)`**
   - `EXTRACTVALUE` 関数は、今回の場合、意図的なエラーを発生させるために使用される
   - 関数が無効な XML データ（ここでは `id` と `password` の連結結果）を処理しようとすると、エラーメッセージが発生する

- `EXTRACTVALUE` 関数は無効な XML データを処理しようとするとエラーを発生させ、このエラーメッセージには `id` と `password` の連結結果が含まれる可能性がある
- この方法で、攻撃者は `users` テーブルの機密情報（ユーザー ID とパスワード）を外部に漏洩させることができる

### `UNION SELECT` を用いた情報漏洩

:::details UNION SELECT とは？

1. **目的**: `UNION SELECT` は異なる SQL クエリの結果を一つの結果セットに結合する

2. **条件**:

   - 結合する各クエリは同じ数の列を持つ必要がある
   - 対応する列のデータ型は互換性が必要

3. **動作**:

   - `UNION` は異なる SELECT 文の結果を合わせ、重複する行を取り除く
   - `UNION ALL` は重複を含めてすべての結果を合わせる

4. **使用例**:

   - テーブル A とテーブル B があり、両方のテーブルから都市名を選択する場合：
     ```sql
     SELECT city FROM tableA
     UNION
     SELECT city FROM tableB
     ```
   - この例では、tableA と tableB の両方から「city」列を選択し、重複する都市名を排除して一つのリストとして表示する

5. **パフォーマンス**:

   - `UNION` は重複除去の処理があるため、`UNION ALL` よりも処理が遅くなることがある

6. **用途**:
   - データレポート、異なるテーブルからのデータ集約、異なるソースからの情報統合に利用される

:::

`$author` に以下の値が注入されたとする。

```
' UNION SELECT id, password, name, address, NULL, NULL, NULL FROM users--
```

この値を元のクエリに挿入すると、以下のようになる。

```sql
SELECT * FROM books WHERE author = '' UNION SELECT id, password, name, address, NULL, NULL, NULL FROM users--' ORDER BY id;
```

クエリの内容は以下の通り。

1. **最初の `'` で文字列リテラルを閉じる**
   - これにより、元の `author` 条件が終了する
2. **`UNION SELECT`**
   - 別の `SELECT` 文を追加して、元のクエリの結果セットに追加の行を結合する
3. **`id, password, name, address, NULL, NULL, NULL FROM users`**
   - `users` テーブルから `id`, `password`, `name`, `address` 列を選択し、`books` テーブルの列数に合わせるために残りの列に `NULL` を使用する
4. **`--` で残りのクエリをコメントアウト**
   - これにより、元のクエリの `ORDER BY id` 部分は無視される

- この攻撃により、攻撃者は `users` テーブルの `id`, `password`, `name`, `address` などの機密情報にアクセスできる可能性がある
- 攻撃者はデータベースの構造に関する情報（例えば、テーブル名や列名）も得ることができる
- `UNION SELECT` を用いた攻撃が成立すると、一度の攻撃で大量の情報を漏洩させられる

### SQL インジェクションによる認証回避

Web アプリケーションでは、ユーザがログインする際に以下のような SQL クエリを使用することが一般的。

```sql
SELECT * FROM users WHERE username = '$username' AND password = '$password';
```

攻撃者は、ユーザー名またはパスワードのフィールドに特別に構成された入力を提供することで、この認証プロセスを悪用する。
例えば、ユーザー名に以下のような値を入力することができる。

```
' OR '1'='1
```

これを元のクエリに挿入すると、クエリは以下のようになる。

```sql
SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '$password';
```

クエリの内容は以下の通り。

1. **最初の `'` で文字列リテラルを閉じる**
   - 攻撃者は最初のシングルクォートを使用して、クエリ内の文字列リテラルを閉じる
2. **`OR '1'='1'`**
   - この部分は常に真と評価される（1 は常に 1 と等しいため）
   - その結果、`username` の条件は無視され、常に真となる
3. **結果として、パスワードのチェックがバイパスされる**
   - このクエリは、有効なユーザー名を必要とせず、どんなパスワードでも真と評価されるため、認証が回避される

この種の攻撃により、攻撃者は権限を持たないユーザーアカウントにアクセスしたり、管理者アカウントに不正アクセスしたりする可能性がある。

### SQL インジェクション攻撃によるデータ改ざん

`$author` に以下の値が注入されたとする。

```
' ; UPDATE books SET author = '攻撃者' WHERE author = '特定の著者' ; --
```

この値を元のクエリに挿入すると、以下のようになる。

```sql
SELECT * FROM books WHERE author = '' ; UPDATE books SET author = '攻撃者' WHERE author = '特定の著者' ; --' ORDER BY id;
```

1. **最初の `'` で文字列リテラルを閉じる**
   - 攻撃者は最初のシングルクォートを使用して、クエリ内の文字列リテラルを閉じる
2. **`;` で SQL ステートメントを終了させる**
   - セミコロンは SQL ステートメントの終わりを示す
3. **`UPDATE books SET author = '攻撃者' WHERE author = '特定の著者'`**
   - 新しいステートメントで `books` テーブルの `author` 列のデータを改ざんする
4. **`--` で残りのクエリをコメントアウト**
   - これにより、元のクエリの ORDER BY id 部分は無視される

この攻撃により、攻撃者はデータベース内のデータを無許可で改ざんすることができる。
これは情報の信頼性を損ない、さらにはデータベースの整合性を破壊する可能性がある。

### その他の攻撃

データベースエンジンによっては、SQL インジェクション攻撃によって、以下が可能になる場合がある。

- OS コマンドの実行
- ファイルの読み出し
- ファイルの書き出し
- HTTP リクエストにより他のサーバを攻撃

## 脆弱性が生まれる原因

- SQL インジェクションとは開発者の意図しない形に SQL 文が改変されること
- その典型的な原因は「**リテラル**」の扱いにある
-

### リテラルとは？

- 「リテラル」とは、プログラムコード内に直接記述される値のこと
- これは変数ではなく、その場でその値を持つデータ
- SQL 文において、リテラルは主に文字列や数値などのデータを表現するために使用される
- リテラルは様々なタイプのデータを表すために使用され、主に以下のカテゴリーに分けられる

1. **文字列リテラル**
   - テキストデータを表し、通常はシングルクォート（`'`）またはダブルクォート（`"`）で囲まれる
   - 例：'Hello', "World"
2. **数値リテラル**
   - 整数や浮動小数点数などの数値を直接表す
   - 例：100, 3.14
3. **論理値リテラル**
   - 真（true）または偽（false）の論理値を表す
4. **その他のリテラル**
   - 日付や時間など、特定のフォーマットで表現されるデータ型もある

- 脆弱性の原因は SQL 文における「リテラル」の不適切な扱い
- **文字列リテラルや数値リテラルを含むクエリにおいて、リテラルの終端を意図的に操作されることで、クエリが予期せぬ方法で実行される可能性がある**

### 文字リテラルと SQL インジェクション

例えば、以下のような SQL 文があるとする。

```sql
SELECT * FROM users WHERE username = '$username';
```

もしユーザーが `username` フィールドに `' OR '1'='1` と入力した場合、SQL 文は次のようになる。

```sql
SELECT * FROM users WHERE username = '' OR '1'='1';
```

ここで、攻撃者は `'` を使って文字列リテラルを終了させ、`OR '1'='1'` という新しい条件を追加している。
この条件は常に真となるため、SQL 文はすべてのユーザーデータを返す可能性がある。

### 数値リテラルと SQL インジェクション

例えば、以下のような SQL 文があるとする。

```sql
SELECT * FROM products WHERE id = $id;
```

ここで `$id` はユーザーからの入力（製品の ID）を表す**数値**を想定している。

しかし、攻撃者が数値リテラルの脆弱性を悪用する場合、彼らは次のような値を入力するかもしれない。

```
1 OR 1=1
```

Web アプリケーション開発に広く用いられるスクリプト系の言語（PHP、Perl、Ruby など）は変数に型の制約がないため、数値を想定した変数に数値以外の文字が入る場合がある。

この入力を元のクエリに挿入すると、クエリは以下のようになる。

```sql
SELECT * FROM products WHERE id = 1 OR 1=1;
```

この部分は条件 `1=1` を加えており、これは常に真となる。
よって、`id` が `1` である製品だけでなく、すべての製品が選択される可能性がある。

## 対策
