---
title: "入力処理とセキュリティ"
---

入力値のチェックだけで脆弱性は対策できないが、根本的な対策に穴があった場合の災害を防いだり軽減できる場合がある。

## Web アプリケーションの「入力」では何をするか

- 入力には、HTTP リクエストとして渡されるパラメータ（GET、POST、クッキーなど）がある
- これらの値の受付時の処理を「入力処理」と呼ぶことにする
- 入力処理とは、アプリケーションロジックの処理が始まる前にデータを準備する段階

![](https://storage.googleapis.com/zenn-user-upload/06f7337d72ce-20231223.png)

入力処理では、入力値に対して以下の処理を行う。

1. 文字エンコーディングの妥当性検証
2. 文字エンコーディングの変換（必要な場合のみ）
3. 入力値（パラメータ文字列）の妥当性検証

### 1. 文字エンコーディングの妥当性検証

- 文字コードを使用した攻撃手法を防ぐために行う
- 原理的に言えば、文字列を使うすべての箇所で文字コードの処理が正しくできていれば問題は発生しないはず
- しかし、言語側に脆弱性があるケースや、正しいプログラミングができていないケースで脆弱性が混入する
- 文字エンコーディングとして不正なデータをアプリケーションの入り口ではじいておけば、不正な文字エンコーディングを使った攻撃を防止できる

Node.js で文字エンコーディングの妥当性検証を行う際の例は以下がある。

#### バッファからの文字列デコード

- Node.js では、バッファ（Buffer クラスのインスタンス）はバイナリデータの処理に使われる
- 文字列データをバッファからデコードする際に、正しいエンコーディングを指定することが重要

```js
const buffer = Buffer.from("こんにちは", "utf-8");
const string = buffer.toString("utf-8"); // 正しいエンコーディングでデコード
```

#### 外部データソースからのデータの読み込み

- 外部ファイルや API からデータを読み込む場合、適切なエンコーディングを指定してデータを処理する必要がある
- Node.js の `fs` モジュールを使ってファイルを読み込む際には、エンコーディングを指定できる

```js
const fs = require("fs");

fs.readFile("example.txt", "utf-8", (err, data) => {
  if (err) throw err;
  console.log(data); // UTF-8 エンコーディングで読み込まれる
});
```

#### HTTP リクエストの処理

- HTTP リクエストを受け取る際には、リクエストボディのエンコーディングを確認し、適切に処理する必要がある
- express フレームワークを使用する場合、ミドルウェアを設定してエンコーディングを管理できる

```js
const express = require("express");
const app = express();

app.use(express.json()); // JSONボディの解析
app.use(express.urlencoded({ extended: true })); // URLエンコーディングされたボディの解析

app.post("/api/data", (req, res) => {
  console.log(req.body); // 適切にエンコーディングされたリクエストボディ
  res.send("データ受信");
});

app.listen(3000);
```

### 2. 文字エンコーディングの変換（必要な場合のみ）

- 変換が必要なケースは、HTTP メッセージとプログラム内部で文字エンコーディングが異なる場合
- 文字エンコーディングの変換手段は言語によって異なる
- 大まかな分類として以下 2 つがある
  - 文字エンコーディングを自動的に変換する言語
  - スクリプトで変換ロジックを明示する言語

以下は、Node.js を用いて、URL のクエリパラメータから `name` を取得し、それを Shift_JIS から UTF-8 に変換する例。

```js
const express = require("express");
const iconv = require("iconv-lite");
const app = express();

app.get("/", (req, res) => {
  let name = req.query.name || ""; // URLパラメータからnameを取得

  // Shift_JISからUTF-8にエンコーディングを変換
  if (!iconv.encodingExists("Shift_JIS")) {
    res.send("サーバーがShift_JISエンコーディングをサポートしていません。");
    return;
  }

  name = iconv.decode(Buffer.from(name, "binary"), "Shift_JIS");
  name = iconv.encode(name, "UTF-8").toString();

  // XSS対策
  name = escapeHtml(name);

  res.send(`<body>名前は${name}です</body>`);
});

const escapeHtml = (str) => {
  return str.replace(/[&<>"']/g, (char) => {
    switch (char) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&#039;";
      default:
        return char;
    }
  });
};

const port = 3000;
app.listen(port, () => {
  console.log(`サーバーがポート${port}で起動しました。`);
});
```

#### クエリパラメータの取得

```js
let name = req.query.name || "";
```

- `req.query.name` は Express のルーティング機能を使用して、HTTP GET リクエストの URL クエリパラメータから `name` の値を取得する
- `name` パラメータが存在しない場合、空文字にする

#### Shift_JIS から UTF-8 へのエンコーディング変換

```js
if (!iconv.encodingExists("Shift_JIS")) {
  res.send("サーバーがShift_JISエンコーディングをサポートしていません。");
  return;
}

name = iconv.decode(Buffer.from(name, "binary"), "Shift_JIS");
name = iconv.encode(name, "UTF-8").toString();
```

- `iconv.encodingExists('Shift_JIS')` は、`iconv-lite` ライブラリが Shift_JIS エンコーディングをサポートしているかどうかをチェックする
- `iconv.decode(Buffer.from(name, 'binary'), 'Shift_JIS')` は、入力された `name` をバイナリデータとして扱い、Shift_JIS エンコーディングからデコード（文字列に変換）
- `iconv.encode(name, 'UTF-8')` は、デコードされた文字列を UTF-8 エンコーディングに変換する

#### XSS 対策

```js
res.send(`<body>名前は${name}です</body>`);
```

- `escapeHtml` 関数は、`name` に含まれる可能性のある HTML 特殊文字列を安全な文字列にエスケープする
- これにより、XSS 攻撃を防ぐことができる

### 3. 入力値の検証

文字エンコーディング関連の処理が終わったら、入力値の検証を行う。

#### 入力値検証の目的

1. **入力値の間違いを早期に発見して再入力を促すことにより、ユーザビリティを向上する**
2. **間違った処理を継続することによるデータの不整合などを防ぎ、システムの信頼性を向上させる**

入力値検証のないアプリケーションでは、以下のような現象が起こる。

- 数値のみを受け付ける項目に英字や記号を入力して、DB のエラーになる
- 更新処理が途中でエラーになり、DB の不整合が発生する
- 利用者が多数の項目を入力して実行ボタンをクリックしたら内部エラーとなり、入力を最初からやり直すはめになる
- メールアドレスの入力を忘れているのにアプリケーションがメール送信処理を実行する

入力値検証はこのような問題が起こる可能性を減らす。
入力値検証は書式のチェックのみで、それ以外の条件（在庫があるか？、預金残高が足りているか？など）はチェックしない。
そのため、エラーをゼロにはできないが、ユーザの入力ミスを早期に発見できる。

#### 入力値検証とセキュリティ

入力値検証の主目的ではないが、セキュリティのために役立つ場合もある。
以下のようなケースに役立つ。

- SQL インジェクション対策が漏れていたパラメータがあるが、英数字のみ許可していたので実害には至らない
- PHP のバイナリセーフでない関数（後述）を使っているが、入力段階で制御文字をチェックしているので実害には至らない
- 表示処理の関数に文字エンコーディングの指定を怠っているが、入力段階で不正な文字エンコーディングをチェックしているので実害には至らない

#### バイナリセーフ

- データをバイナリ（二進数）レベルで正確に扱えること
- ファイル操作やネットワーク通信、文字列処理などのコンテキストで使用される
- バイナリセーフな関数や操作は、データをそのバイト値に基づいて扱い、データの内容や形式（テキスト、バイナリファイル、画像など）に依存しない

主要な特徴は以下の通り。

1. **バイト列の正確な取り扱い**
   - データを単なるバイトの列として扱い、その値を変更したり解釈したりしない
   - これにより、任意のバイト値（0 から 255 まで）を含むデータを正確に扱える
2. **エンコーディングの中立生**
   - テキストデータの場合、バイナリセーフな操作は特定の文字エンコーディングに依存しない
   - これは、マルチバイト文字セットや特殊なエンコーディングを使用する場合に重要
3. **任意のデータタイプの処理**
   - バイナリデータ（例えば画像ファイルや実行可能ファイル）、テキストデータ、その他の形式のデータに対して同様に機能する
4. **特殊文字の問題がない**
   - テキスト処理では特定の文字（例えばヌル文字\0）が終端文字として扱われることがあるが、バイナリセーフな操作ではこれらの特殊文字が問題を引き起こさない

#### ヌルバイト攻撃

1. **概要**
   - セキュリティの脆弱性を利用する攻撃方法の一つ
   - セキュリティシステムを騙すためにヌル文字（バイト値が 0 の文字）を使用する攻撃方法
   - 特に C 言語やその他の言語の一部の関数がヌル文字（`\0`）を文字列の終端として扱う特性を悪用する
2. **攻撃の仕組み**
   - 攻撃者は意図的にヌル文字をデータに挿入し、システムが文字列を早期に終了させるようにする
   - これにより、システムは本来の意図と異なる方法でデータを処理し、セキュリティ上の脆弱性が生じる

#### ヌルバイト攻撃の例

- ユーザーが画像ファイル（例：.jpg、.png）をアップロードできる機能を考える
- セキュリティ対策として、アプリケーションはアップロードされるファイルの拡張子をチェックして、不正なファイル（例：実行可能ファイルの.exe）のアップロードを防ぐよう設計する

1. **攻撃の準備**

   - 攻撃者は、悪意あるファイルの名前にヌル文字を挿入する
   - 例えば、`malicious.exe` というファイル名を `malicious.jpg\u0000.exe` に変更する
   - ここで、`\u0000` はヌル文字を表す。

2. **攻撃の実行**

   - 攻撃者はこの改変されたファイル名でファイルをアップロードしようとする
   - システムはファイル名をチェックする際、ヌルバイトに到達すると、それ以降の文字列を無視する
   - その結果、アプリケーションはファイル名を `malicious.jpg` として認識する

3. **セキュリティチェックの回避**
   - アプリケーションがファイル名の拡張子をチェックすると、`.jpg` と判断し、画像ファイルとして安全だと誤認する
   - 実際のファイルは `malicious.jpg\u0000.exe` であり、システムにアップロードされた後、悪意のあるコードを実行する可能性がある

## ヌルバイト攻撃の対応策

- 根本対策は、バイナリセーフの関数のみを用いてアプリケーションを開発すること
- しかし、現実的にはファイル名のように仕様上ヌルバイトを許容しないパラメータがあるため、困難
- アプリケーションの入り口でバイナリセーフの関数を用いて入力値のヌルバイトをチェックし、ヌルバイトがあればエラーにすることにより確実な対応が可能になる
