---
title: "入力処理とセキュリティ"
---

入力値のチェックだけで脆弱性は対策できないが、根本的な対策に穴があった場合の災害を防いだり軽減できる場合がある。

## Web アプリケーションの「入力」では何をするか

- 入力には、HTTP リクエストとして渡されるパラメータ（GET、POST、クッキーなど）がある
- これらの値の受付時の処理を「入力処理」と呼ぶことにする
- 入力処理とは、アプリケーションロジックの処理が始まる前にデータを準備する段階

![](https://storage.googleapis.com/zenn-user-upload/06f7337d72ce-20231223.png)

入力処理では、入力値に対して以下の処理を行う。

1. 文字エンコーディングの妥当性検証
2. 文字エンコーディングの変換（必要な場合のみ）
3. 入力値（パラメータ文字列）の妥当性検証

## 1. 文字エンコーディングの妥当性検証

- 文字コードを使用した攻撃手法を防ぐために行う
- 原理的に言えば、文字列を使うすべての箇所で文字コードの処理が正しくできていれば問題は発生しないはず
- しかし、言語側に脆弱性があるケースや、正しいプログラミングができていないケースで脆弱性が混入する
- 文字エンコーディングとして不正なデータをアプリケーションの入り口ではじいておけば、不正な文字エンコーディングを使った攻撃を防止できる

Node.js で文字エンコーディングの妥当性検証を行う際の例は以下がある。

#### バッファからの文字列デコード

- Node.js では、バッファ（Buffer クラスのインスタンス）はバイナリデータの処理に使われる
- 文字列データをバッファからデコードする際に、正しいエンコーディングを指定することが重要

```js
const buffer = Buffer.from("こんにちは", "utf-8");
const string = buffer.toString("utf-8"); // 正しいエンコーディングでデコード
```

#### 外部データソースからのデータの読み込み

- 外部ファイルや API からデータを読み込む場合、適切なエンコーディングを指定してデータを処理する必要がある
- Node.js の `fs` モジュールを使ってファイルを読み込む際には、エンコーディングを指定できる

```js
const fs = require("fs");

fs.readFile("example.txt", "utf-8", (err, data) => {
  if (err) throw err;
  console.log(data); // UTF-8 エンコーディングで読み込まれる
});
```

#### HTTP リクエストの処理

- HTTP リクエストを受け取る際には、リクエストボディのエンコーディングを確認し、適切に処理する必要がある
- express フレームワークを使用する場合、ミドルウェアを設定してエンコーディングを管理できる

```js
const express = require("express");
const app = express();

app.use(express.json()); // JSONボディの解析
app.use(express.urlencoded({ extended: true })); // URLエンコーディングされたボディの解析

app.post("/api/data", (req, res) => {
  console.log(req.body); // 適切にエンコーディングされたリクエストボディ
  res.send("データ受信");
});

app.listen(3000);
```

## 2. 文字エンコーディングの変換（必要な場合のみ）

- 変換が必要なケースは、HTTP メッセージとプログラム内部で文字エンコーディングが異なる場合
- 文字エンコーディングの変換手段は言語によって異なる
- 大まかな分類として以下 2 つがある
  - 文字エンコーディングを自動的に変換する言語
  - スクリプトで変換ロジックを明示する言語

以下は、Node.js を用いて、URL のクエリパラメータから `name` を取得し、それを Shift_JIS から UTF-8 に変換する例。

```js
const express = require("express");
const iconv = require("iconv-lite");
const app = express();

app.get("/", (req, res) => {
  let name = req.query.name || ""; // URLパラメータからnameを取得

  // Shift_JISからUTF-8にエンコーディングを変換
  if (!iconv.encodingExists("Shift_JIS")) {
    res.send("サーバーがShift_JISエンコーディングをサポートしていません。");
    return;
  }

  name = iconv.decode(Buffer.from(name, "binary"), "Shift_JIS");
  name = iconv.encode(name, "UTF-8").toString();

  // XSS対策
  name = escapeHtml(name);

  res.send(`<body>名前は${name}です</body>`);
});

const escapeHtml = (str) => {
  return str.replace(/[&<>"']/g, (char) => {
    switch (char) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&#039;";
      default:
        return char;
    }
  });
};

const port = 3000;
app.listen(port, () => {
  console.log(`サーバーがポート${port}で起動しました。`);
});
```

#### クエリパラメータの取得

```js
let name = req.query.name || "";
```

- `req.query.name` は Express のルーティング機能を使用して、HTTP GET リクエストの URL クエリパラメータから `name` の値を取得する
- `name` パラメータが存在しない場合、空文字にする

#### Shift_JIS から UTF-8 へのエンコーディング変換

```js
if (!iconv.encodingExists("Shift_JIS")) {
  res.send("サーバーがShift_JISエンコーディングをサポートしていません。");
  return;
}

name = iconv.decode(Buffer.from(name, "binary"), "Shift_JIS");
name = iconv.encode(name, "UTF-8").toString();
```

- `iconv.encodingExists('Shift_JIS')` は、`iconv-lite` ライブラリが Shift_JIS エンコーディングをサポートしているかどうかをチェックする
- `iconv.decode(Buffer.from(name, 'binary'), 'Shift_JIS')` は、入力された `name` をバイナリデータとして扱い、Shift_JIS エンコーディングからデコード（文字列に変換）
- `iconv.encode(name, 'UTF-8')` は、デコードされた文字列を UTF-8 エンコーディングに変換する

#### XSS 対策

```js
res.send(`<body>名前は${name}です</body>`);
```

- `escapeHtml` 関数は、`name` に含まれる可能性のある HTML 特殊文字列を安全な文字列にエスケープする
- これにより、XSS 攻撃を防ぐことができる

## 3. 入力値（パラメータ文字列）の検証

文字エンコーディング関連の処理が終わったら、入力値の検証を行う。

### 入力値検証の目的

1. **入力値の間違いを早期に発見して再入力を促すことにより、ユーザビリティを向上する**
2. **間違った処理を継続することによるデータの不整合などを防ぎ、システムの信頼性を向上させる**

入力値検証のないアプリケーションでは、以下のような現象が起こる。

- 数値のみを受け付ける項目に英字や記号を入力して、DB のエラーになる
- 更新処理が途中でエラーになり、DB の不整合が発生する
- 利用者が多数の項目を入力して実行ボタンをクリックしたら内部エラーとなり、入力を最初からやり直すはめになる
- メールアドレスの入力を忘れているのにアプリケーションがメール送信処理を実行する

入力値検証はこのような問題が起こる可能性を減らす。
入力値検証は書式のチェックのみで、それ以外の条件（在庫があるか？、預金残高が足りているか？など）はチェックしない。
そのため、エラーをゼロにはできないが、ユーザの入力ミスを早期に発見できる。

### 入力値検証とセキュリティ

入力値検証の主目的ではないが、セキュリティのために役立つ場合もある。
以下のようなケースに役立つ。

- SQL インジェクション対策が漏れていたパラメータがあるが、英数字のみ許可していたので実害には至らない
- PHP のバイナリセーフでない関数（後述）を使っているが、入力段階で制御文字をチェックしているので実害には至らない
- 表示処理の関数に文字エンコーディングの指定を怠っているが、入力段階で不正な文字エンコーディングをチェックしているので実害には至らない

### バイナリセーフ

- データをバイナリ（二進数）レベルで正確に扱えること
- ファイル操作やネットワーク通信、文字列処理などのコンテキストで使用される
- バイナリセーフな関数や操作は、データをそのバイト値に基づいて扱い、データの内容や形式（テキスト、バイナリファイル、画像など）に依存しない

主要な特徴は以下の通り。

1. **バイト列の正確な取り扱い**
   - データを単なるバイトの列として扱い、その値を変更したり解釈したりしない
   - これにより、任意のバイト値（0 から 255 まで）を含むデータを正確に扱える
2. **エンコーディングの中立生**
   - テキストデータの場合、バイナリセーフな操作は特定の文字エンコーディングに依存しない
   - これは、マルチバイト文字セットや特殊なエンコーディングを使用する場合に重要
3. **任意のデータタイプの処理**
   - バイナリデータ（例えば画像ファイルや実行可能ファイル）、テキストデータ、その他の形式のデータに対して同様に機能する
4. **特殊文字の問題がない**
   - テキスト処理では特定の文字（例えばヌル文字\0）が終端文字として扱われることがあるが、バイナリセーフな操作ではこれらの特殊文字が問題を引き起こさない

### ヌルバイト攻撃

1. **概要**
   - セキュリティの脆弱性を利用する攻撃方法の一つ
   - セキュリティシステムを騙すためにヌル文字（バイト値が 0 の文字）を使用する攻撃方法
   - 特に C 言語やその他の言語の一部の関数がヌル文字（`\0`）を文字列の終端として扱う特性を悪用する
2. **攻撃の仕組み**
   - 攻撃者は意図的にヌル文字をデータに挿入し、システムが文字列を早期に終了させるようにする
   - これにより、システムは本来の意図と異なる方法でデータを処理し、セキュリティ上の脆弱性が生じる

### ヌルバイト攻撃の例

- ユーザーが画像ファイル（例：.jpg、.png）をアップロードできる機能を考える
- セキュリティ対策として、アプリケーションはアップロードされるファイルの拡張子をチェックして、不正なファイル（例：実行可能ファイルの.exe）のアップロードを防ぐよう設計する

1. **攻撃の準備**

   - 攻撃者は、悪意あるファイルの名前にヌル文字を挿入する
   - 例えば、`malicious.exe` というファイル名を `malicious.jpg\u0000.exe` に変更する
   - ここで、`\u0000` はヌル文字を表す。

2. **攻撃の実行**

   - 攻撃者はこの改変されたファイル名でファイルをアップロードしようとする
   - システムはファイル名をチェックする際、ヌルバイトに到達すると、それ以降の文字列を無視する
   - その結果、アプリケーションはファイル名を `malicious.jpg` として認識する

3. **セキュリティチェックの回避**
   - アプリケーションがファイル名の拡張子をチェックすると、`.jpg` と判断し、画像ファイルとして安全だと誤認する
   - 実際のファイルは `malicious.jpg\u0000.exe` であり、システムにアップロードされた後、悪意のあるコードを実行する可能性がある

### ヌルバイト攻撃の対応策

- 根本対策は、バイナリセーフの関数のみを用いてアプリケーションを開発すること
- しかし、現実的にはファイル名のように仕様上ヌルバイトを許容しないパラメータがあるため、困難
- アプリケーションの入り口でバイナリセーフの関数を用いて入力値のヌルバイトをチェックし、ヌルバイトがあればエラーにすることにより確実な対応が可能になる

### 入力値検証だけでは対策にならない

- 入力段階の検証では、脆弱性対策にはならない
- 入力値検証はアプリケーションの仕様が基準
- 例えば「すべての文字を許容する」という仕様の場合は入力時点では何も防げない
- よって、入力値検証は保険的対策として捉えるべき

### 入力値検証の基準はアプリケーション要件

- 入力値を検証する際の基準はアプリケーションの仕様
- 「電話番号であれば数字のみである」や「ユーザ ID は英数字 8 文字」など、文字種や文字数などの書式を仕様に基づいて確認する

#### 制御文字のチェック

:::details 制御文字とは？
改行（キャリッジリターンおよびラインフィード）やタブなど、通常表示されることのない、ASCII コード 0x20 未満および 0x7F（DELETE）の文字のこと。
ヌルバイトも制御文字の一種。
:::

- Web アプリケーションの入力パラメータはテキストの場合が多い
- よって、制御文字に関しては制限を掛けるべき
- `<input />` の `type='text'` や `type='password'` には、通常の入力方法では制御文字は入力できない
- `<textarea />` の場合は改行とタブの入力が可能であるため、改行とタブを許可するかどうかはアプリ側の仕様として決める必要がある

#### 文字数のチェック

- **全てのパラメータに最大文字数を仕様として定義すべき**
- DB に格納するデータであれば、列を定義するために、最大文字数の仕様を決めているはず
- 物理的な上限値のない場合でも、動作保証するために最大文字数を決める必要がある
- 最大文字数をチェックしておくと、セキュリティ上の保険的対策になる場合がある
  - 脆弱性を狙った攻撃には長い文字列を要する場合がある
  - 例えば 10 文字以内という制限が掛かっていると、「SQL インジェクション脆弱性はあるが文字数制限により攻撃には至らない」というケースもあり得る
- 過度な期待は禁物だが、**文字数の検査はセキュリティ上の役に立つ**

#### 数値の最小値・最大値のチェック

- 値が取りうる最小値と最大値の仕様を定める
- この検証がセキュリティの役に立つ場合もある
- 例えば、入力された数値に応じてメモリを確保するアプリであれば、大きな数字を指定することでメモリ使用量が過大になる場合がある
- これにより、アプリの応答が遅くなったり、サービスが停止するなどの被害が生じる（DoS 攻撃）

数値項目については、入力時に以下を行う。

- **数値文字列としての文字種・文字数のチェック**
- **文字列型から数値型への型変換**
- **最小値・最大値の範囲にあることの確認**

### どのパラメータを検証するか

- 全てのパラメータ
- `hidden` パラメータ、ラジオボタン、`<select />` なども含まれる
- クッキーにセッション ID 以外の値を入れているときは、クッキーの値も検証する
- `Refer` など HTTP ヘッダをアプリケーションが利用している場合も検証対象

## まとめ

- 入力値検証はアプリケーション仕様に基づいて行う
- 文字エンコーディングの検証
- 制御文字を含む文字種の検証
- 文字数の検証
- 数値の最小値・最大値の検証

実施手順は以下の通り。

1. 設計段階で各パラメータの文字種および最大文字数、最小値・最大値を仕様として決める
2. 設計段階で入力値検証の実装方針を決める
3. 開発段階では仕様に従い入力値検証を実装する
