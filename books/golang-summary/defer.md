---
title: "defer"
---

`defer`は、Go 言語の特徴的な機能の 1 つで、特定の関数呼び出しを遅延実行するために使用されます。`defer`は関数内で定義されたコードの最後に実行され、主にリソースの解放やクリーンアップのために使用されます。以下に`defer`の基本的な動作と使用方法を説明します。

`defer`の基本的な構文は次の通りです：

```go
func someFunction() {
    // 処理1
    defer cleanupFunction()
    // 処理2
}
```

`cleanupFunction`は`someFunction`が終了する前に遅延実行されます。つまり、`cleanupFunction`は`someFunction`が正常に終了したり、エラーで終了した場合にも確実に実行されます。

`defer`に関する重要なポイント:

1. **複数の`defer`ステートメント**:

   - 関数内で複数の`defer`ステートメントを使用できます。これらは後で定義された順序で実行されます。

2. **スタックの動作**:

   - `defer`はスタック（Last In, First Out）の動作をします。最後に宣言された`defer`が最初に実行されます。したがって、複数の`defer`がある場合、最初に宣言した`defer`が最後に実行されます。

3. **引数の評価**:

   - `defer`内の関数呼び出しの引数は、`defer`ステートメントが実行される時点では評価されます。そのため、遅延実行時に引数の値が確定しています。

4. **遅延実行時の適用**:
   - `defer`はリソースの確実な解放に非常に役立ちます。ファイルのクローズ、ネットワーク接続のクローズ、ロックの解除など、リソース管理に関連するタスクに使用できます。

以下は具体的な使用例です：

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Error opening file")
        return
    }
    defer file.Close() // ファイルを遅延クローズ

    // ファイルからデータを読み込む処理

    // この時点でdeferによってfile.Close()が確実に実行される
}
```

この例では、ファイルを遅延クローズして、エラーが発生してもリソースが確実に解放されます。`defer`はエラーハンドリングの一部としても非常に役立ちます。
