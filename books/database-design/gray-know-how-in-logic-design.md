---
title: "論理設計のグレーノウハウ"
---

- グレーノウハウは、節度ある利用に限り、有効に作用する「良薬」になりえる
- 利点と欠点のバランスを身長に考える必要がある

## 代理キー

- 主キーが役に立たないときに使用されるキー

### 主キーが決められない・主キーとして不十分なケース

#### 1. そもそも入力データに主キーにできるような一意キーが存在しない

- 一意キーが存在せず、主キーを定義できない場合
- 入力インターフェースではレコードの二重登録を許容し、後にレコードの重複を排除する処理が行われる場合など

#### 2. 一意キーは存在するが、サイクリックに使いまわされる

- 主キーの値が全て使われてしまった場合に、既存の値が使われるケースで発生する
- 下記テーブルの主キーには、`市町村コード` という `A + 3桁の数字` からなるコードを使う
- A000〜A999 までの 1000 個の市町村を登録すると、1001 個目の市町村を登録できない
- そのため、「すでに廃止された市町村のコードを使い回す」という選択を余儀なくされる

![](https://storage.googleapis.com/zenn-user-upload/0c9df349012e-20231029.png)

- これでは、市町村の履歴管理を行うことができない
- 同じ `A001` のコードが、ある年度までは `B市` を意味していたが、途中で `Q市` になるケースが発生する
- 常に最新のコードしか使用しないならこの運用でも問題ない
- しかし、時系列で過去のデータを取得したい場合などには対応できない

#### 3. 一意キーは存在するが、途中で指す対象が変化する

- パターン 2 と似ている
- 「値の枯渇ではない」点が違う
- C 町と D 村が合併する場合
  - D 村が C 町に吸収され、合併後の名前は「C 町」が使われる

![](https://storage.googleapis.com/zenn-user-upload/a23f08675170-20231029.png)

- `A002` は、表向きは `C町` を指す
- しかし、内容は大きく変わっている（人口が変化している）
- 本来であれば、合併前と合併後の情報は分けて履歴管理したい

### 代理キー（サロゲートキー）による解決

- 入力データに最初から存在しているキーの「代理」として新たに追加するキー

![](https://storage.googleapis.com/zenn-user-upload/235385552ea6-20231029.png)

- `市町村管理コード` という代理キーを用意する
- これにより、`市町村コード` 「`A001`」が再利用されて重複が発生しても、一意な連番を割り振ることができる
- **人工的なキー**をシステム側で付与してやることで、自然キーを主キーにした場合に発生する不都合を解消できる
- また、主キーが複合キーの場合、SQL の WHERE 句における条件記述を代理キーであればシンプルにできる

### 代理キーはなぜグレーノウハウなのか？

- 代理キーはそもそも論理的には不要なキー
- 論理モデルをわかりにくくしてしまう
- 業務的には不要なキーである
- 代理キーが何の役割を果たしているのかは、ER 図を一読しても変わらない
- 代理キーは「使わなくても何とかなる」道具

### 自然キーによる解決

代理キーの使用検討をするパターンは

1. そもそも入力データに主キーにできるような一意キーが存在しない
2. 一意キーは存在するが、サイクリックに使いまわされる
3. 一意キーは存在するが、途中で指す対象が変化する

- パターン 1 はそもそも自然キーに主キーが存在しない
- よって、対策としては
  - 業務仕様を調整する
  - DB に投入される前のアプリケーション側でデータが一意になるよう整形する
- パターン 2,3 は自然キーによる解決が可能
- 履歴管理のための時間を表す列を追加する方法
- **タイムスタンプ**と**インターバル**の 2 種類が存在する

#### タイムスタンプ

![](https://storage.googleapis.com/zenn-user-upload/706b8d0ddbb9-20231029.png)

- 2005 年、2006 年、2007 年と、それぞれのタイミングにおけるレコード集合を用意する
- データのスナップショット（断面）を必要な数だけ用意する感じ
- それぞれの断面が履歴の役割を果たす
- `年度` 列は、業務的に意味を持つ「自然キー」
- データの形式が単縦であるため、SQL の条件が簡単になる
- しかし、必ず一つのスナップショットに含まれる市町村をフルセットで保持しなければならないため、レコード数が増える

#### インターバル

- データの有効な「期間」を表す方法

![](https://storage.googleapis.com/zenn-user-upload/604271e8d948-20231029.png)

- `開始年度` と `終了年度` を持つことで、データの有効期間を示す
- `終了年度` に `9999` を指定している場合は、まだ存続していることを示す
  - `NULL` でもいいが、SQL の使い勝手を考えると、最大値を利用するほうが良い
- スナップショット別にデータを持つ必要がなくなり、レコード数を抑えられる
- しかし、データを利用する際に SQL で範囲指定の条件を入れる必要があり、SQL が複雑になる

## オートナンバリング

- 1 レコードに一意な数値を自動的に割り振る方法
- 主キーとして使用するには、2 つの要件を守る必要がある
  1. 重複値が生じないこと（一意性の保証）
  2. 歯抜けが生じないこと（連続性の保証）
- 「連続性の保証」を満たすべきかは業務要件に依存する
- この要件を満たすためには、2 つの方法がある
  1. DB の機能を利用する
  2. アプリケーションで対処する

### DB の機能を利用する

標準 SQL には、オートナンバリングを実現するために、以下の機能が定義されている。

- シーケンスオブジェクト
- ID 列

#### シーケンスオブジェクト

- アクセスすることで、一意な連番を払い出すオブジェクト
- `SELECT` 文でアクセスすることで重複のない連番を取得できる
- 開始値、最大値、カウントアップの増分、最大値に達したときにサイクリックに開始値から再び採番するか、などの条件をオプションで指定できる
- ID 列に比べて細かい制御ができる
- しかし、比較的新しい機能であるため、すべての DBMS がサポートしているとは限らない

#### ID 列

- 一意な連番を払い出すデータ型
- テーブルで使用する主キーとして、このデータ型を採用する
- 指定できるオプションは、開始と増分ぐらい
- 欠点として、DBMS ごとに実装が統一されておらず、**移植性が低い**
  - SQL Server : `IDENTITY` 型
  - PostgreSQL : `SERIAL` 型
  - MySQL : `AUTO_INCREMENT` 型

:::message
**可能な限り、シーケンスオブジェクトを使用する。**
:::

### アプリケーション側で実装

- 「採番テーブル」を利用する
- 1 行 1 列の整数型データを持つ採番デーブルを用意する
- 他のテーブルにデータを登録するたびにインクリメントしていく

![](https://storage.googleapis.com/zenn-user-upload/6a822daaddcb-20231029.png)

#### デメリット

- プログラムの開発とテストが必要になり、コストがかかる
- 採番テーブルと連番を使用するテーブルとは密接に関連していて、片方が欠けたらシステムは動かないが、ER 図からはそのような依存関係がわからない
- 排他制御の仕組みをきちんと作らないと機能的なバグを生み出してしまう
  - 一人が採番テーブルにアクセスした時点でテーブルをロックし、他の人間は参照も更新もできないようにする必要がある

:::message
**オートナンバリングはアプリケーション側で実装しない。**
:::

## 列持ちテーブル

- 以下のようなテーブルのこと
- 「繰り返し項目テーブル」とも呼ぶ

**扶養者テーブル**
| 社員 ID | 社員名 | 子 1 | 子 2 | 子 3 |
| ----- | ----- | ----- | ----- | ----- |
| 000A | 加藤 | 達夫 | 信ニ | |
| 000A | 藤本 | 達夫 | 信ニ | |
| 000A | 三島 | 敦 | 陽子 | 清美 |

- プログラミング言語では、`kodomo[0]`、`kodomo[1]`、`kodomo[2]` ...のような形で子のデータを配列に保持する
- これをテーブルの「列」を使用して模したものが列持ちテーブル

### メリット

1. シンプルな設計
2. 入出力のフォーマットと合わせやすい

### デメリット

1. **列の増減が難しい**
   - RDB のテーブルは、一度作ると後になってから構成を変更するのが難しい
   - 拡張性に乏しい
   - 変更する場合、コストが高くなりがち
   - テーブルの列も配列ほど柔軟に要素数を変化できない
2. **無用の NULL を使う必要がある**
   - 子がいない or 子の数が少ない社員はその列に `NULL` を使用しなければならない
   - `NULL` は RDB において非常に厄介な性質を持っている
   - `NULL` が演算に含まれると、SQL の結果を混乱させる原因になる

### 行持ちテーブル

**扶養者テーブル**
| 社員 ID | 枝番 | 子 |
| ---- | ---- | ---- |
| 000A | 1 | 達夫 |
| 000A | 2 | 信ニ |
| 001F | 1 | 敦 |
| 001F | 2 | 陽子 |
| 001F | 3 | 清美 |

- 列持ちテーブルと行待ちテーブルは、SQL によって簡単に変換が可能
- よって、最初は拡張性の高い行持ちテーブルでデータを保持しておく
- パフォーマンス上の問題でどうしても列持ちテーブルが必要になれば、列持ちテーブルを作る

## アドホックな集計キー

**都道府県テーブル**
| 県コード | 県名 | 人口（万人）|
| ---- | ---- | ---- |
| 01 | 北海道 | 550 |
| 02 | 青森 | 130 |
| 03 | 岩手 | 133 |
| 22 | 静岡 | 370 |
| 23 | 愛知 | 740 |
| 24 | 三重 | 185 |
| 36 | 徳島 | 78 |
| 37 | 香川 | 99 |

- 上記テーブルから地方別の人口の合計を求める
  - 「東北 = 北海道 + 青森 + 岩手」みたいな感じ
- SQL で行うには、`GROUP BY` を組み合わせる
- しかし、集約キーにとして使用したい `地方コード` が存在しない
- そのため、`地方コード` 列を追加する

![](https://storage.googleapis.com/zenn-user-upload/5fa0c54e951b-20231029.png)

- しかし、こうしたアドホックな（場当たり的な）キーは、コード体系が短いスパンで変わったり、別のコード体系が必要になる
- その度に、サイズの大きいテーブルにアドホックキーを次から次へと追加すると、ただでさえ規模の大きなテーブルがますます巨大になり、パフォーマンスを劣化させる

### アドホックなキーの解決策

#### 1. キーを別テーブルに分離する

- 都道府県と地方の変換テーブルを作る

**都道府県-地方テーブル**
| 県コード | 地方コード |
| ---- | ---- |
| 01 | 01 |
| 02 | 01 |
| 03 | 01 |
| 22 | 02 |
| 23 | 02 |
| 24 | 02 |
| 36 | 03 |
| 37 | 03 |

- 変換テーブルのレコード数は、トランザクションテーブルに比べてかなり小さくなる
- メンテナンスも容易
- SQL では結合処理が必要になるため、パフォーマンス問題の解決にはあまり寄与しない

#### 2. ビューを使う

- オリジナルのテーブルには手を加えず、地方コードを追加したビューを用意する
- これにより、そのビューへのアクセスによって簡単に地方単位の集計を行う SQL が記述できる
- 実質的にオリジナルのテーブルへアクセスするのとコストは変わらない
- 必要なコードの数だけビューを作成しても、パフォーマンスを劣化させない

#### 3. `GROUP BY` の中でアドホックキーを、「アドホック」に作る

```sql
SELECT CASE WHEN 県コード IN ("01", "02", "03") THEN "01"
       WHEN 県コード IN　("22", "23", "24") THEN "02"
       WHEN 県コード IN ("36", "37") THEN "03"
       ELSE NULL END AS 地方コード,
     SUM(人口（万人）)
   FROM 都道府県
GROUP BY CASE WHEN 県コード IN　("01", "02", "03") THEN "01"
       WHEN 県コード IN ("22", "23", "24") THEN "02"
       WHEN 県コード IN ("36", "37") THEN "03"
       ELSE NULL END;
```

- `CASE` は「1+1」のような「式」の仲間
- よって、「式」が書ける場所にはどこでも書ける
- `SELECT`、`WHERE`、`GROUP BY`、`HAVING`、`ORDER BY` に書ける

:::details CASE 式について詳しく
SQL の`CASE`文は、データベースクエリにおいて条件に基づいて異なる値や操作を適用するための制御構造です。`CASE`文は、条件に応じて異なる値を選択したり、異なる処理を実行したりする際に非常に役立ちます。通常、`SELECT`ステートメントの中で使用され、結果セットの列の値を条件に応じて変更します。

`CASE`文は通常、2 つの形式で使用されます：`CASE`式と`CASE`文。

1. `CASE`式：
   `CASE`式は単一の式を評価し、その結果に基づいて値を返します。基本的な構文は次のとおりです。

   ```sql
   CASE
       WHEN condition1 THEN result1
       WHEN condition2 THEN result2
       ...
       ELSE else_result
   END
   ```

   例を挙げて説明しましょう。以下は、従業員の給与に応じて評価される`CASE`式の例です。

   ```sql
   SELECT
       EmployeeName,
       Salary,
       CASE
           WHEN Salary >= 50000 THEN 'High Salary'
           WHEN Salary >= 30000 THEN 'Moderate Salary'
           ELSE 'Low Salary'
       END AS SalaryCategory
   FROM Employees;
   ```

   このクエリは、各従業員の名前と給与に応じて'SalaryCategory'列を生成します。

2. `CASE`文：
   `CASE`文は`SELECT`ステートメントの中で複数の列に条件に基づいて値を設定する場合に使用します。基本的な構文は次のとおりです。

   ```sql
   SELECT
       column1,
       column2,
       ...
       CASE
           WHEN condition1 THEN result1
           WHEN condition2 THEN result2
           ...
           ELSE else_result
       END AS new_column
   FROM table_name;
   ```

   例を挙げて説明しましょう。以下は、商品の在庫数に応じて在庫ステータスを設定する`CASE`文の例です。

   ```sql
   SELECT
       ProductName,
       StockQuantity,
       CASE
           WHEN StockQuantity > 0 THEN 'In Stock'
           ELSE 'Out of Stock'
       END AS StockStatus
   FROM Products;
   ```

   このクエリは、各商品の名前と在庫数に応じて'StockStatus'列を生成します。

`CASE`文は、データの条件ごとの分類、変換、フィルタリングなど、さまざまな用途で使用できます。条件式は非常に柔軟で、複雑なロジックを記述できます。
:::
