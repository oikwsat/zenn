---
title: "【アンチパターン】テーブルに状態を持たせる"
---

## 状態を持ったテーブル

状態は、時間経過や特定のイベントによって変化する。
例えば、会員情報には「入会手続き中（未認証）」「入会済み（認証済み）」「有料会員」「退会」など様々な状態が考えられる。

これらの状態をどのように扱えばよいのか？

## 状態フラグを持たせる（若干アンチパターン）

![](https://storage.googleapis.com/zenn-user-upload/fc32864d8b18-20240914.png =400x)

- **`is_join`**
  - 入会済みかどうかのフラグ
  - `true` : 入会済み
  - `false` : 入会手続き中
- **`is_paid`**
  - 有料会員かどうかのフラグ
  - `true` : 有料会員
  - `false` : 無料会員
- **`deleted_at`**
  - `null` : 退会してない
  - `null` 以外 : 退会済み

### 何故アンチパターンなのか？

1. **テーブル修正コストが発生する**
   上記 `members` テーブルの場合、状態を表すカラムが 3 つ存在している。（`is_join`, `is_paid`, `deleted_at`）
   この場合、以下のデメリットが生じる。

   - カラム数が状態の数に比例して多くなると、管理が複雑になる
   - 新しい状態を追加したい場合、テーブル変更が必要となり、修正コストがかかる

2. **UNIQUE 制約が使えない**
   `name` カラムに対し、「入会済み会員の重複を許さない」場合、`name` に UNIQUE 制約を付与したくても、退会している会員と退会していない会員の 2 レコード存在する可能性があるため、UNIQUE 制約を付与できない。

   こちらの対処法としては、退会済みメンバーのテーブルを別で用意することで解決できる。

3. **カーディナリティが低くなる**
   2 種類の値しか入らず、カーディナリティが低い。
   よって、フラグが検索時に高頻度で使用される場合（WHERE flag = 0）、ボトルネックになる。

### アンチパターンが許容されるケース

フラグのメリットは、すぐに true か false を判別できる点。
下記条件を満たす場合、テーズルに状態を持たせることは許容される。

- 状態が非常に少ない場合
- 状態が全て明確に決まっており、将来的に増えることがない
- 対象テーブルが小さく、INDEX が不要

## 状態テーブルを作成する（若干アンチパターン）

![](https://storage.googleapis.com/zenn-user-upload/c3d38d5f87e5-20240914.png)

会員テーブルに対し、会員の状態テーブルを作成する。
これにより、状態フラグの設計で生じる以下のデメリットを解消できる。

- テーブル修正コストが発生する
- カーディナリティが低くなる

しかし、こちらもまだデメリットが存在する。

### 何故アンチパターンなのか？

1. **過去の状態を保持できない**
   このパターンでは、「今現在の状態」を知ることはできるが、「過去にどんな状態だったか」を知ることはできない。

   例えば、「以前、有料会員だったが、今は無料会員の会員を取得したい」という要望が来ても、現在無料会員なことしか判別できない。

2. **複数の状態を管理できない**
   現状、`members` テーブルに付与できる状態は 1 つのみ。
   よって、「休会中かつ有料会員の会員」などという情報を問い合わせることはできない。

### アンチパターンが許容されるケース

状態テーブルを作成する設計は、シンプルで状態が増えても対応できる。
下記条件を満たす場合、許容される。

- 過去の状態を保持する必要がない
- 同時に複数の状態が発生する状況が存在しない

## 状態履歴テーブルを作成する

![](https://storage.googleapis.com/zenn-user-upload/6aae5a34e007-20240914.png)

会員テーブルに状態情報を持たせず、すべて会員状態履歴テーブルに記録する。
これにより、会員がいつ、なんの状態になったのかを辿ることができ、状態管理に高い柔軟性を出すことができる。
また、複数の状態を保持することができる。

### デメリット

- 問い合わせクエリが複雑になる
- 状態が複数存在できるため、アプリ側で状態が単数 or 複数かを判別する必要がある

最新の状態を取得するクエリは以下のようになる。

```sql
-- name="user123"のユーザーの状態を取得する
SELECT
    m.name,
    ms.name,
    msh.created_at
FROM
    members m
    INNER JOIN
        member_status_hisyory msh-- 会員状態履歴テーブル
    ON  m.id = msh.member_id
    INNER JOIN
        member_status ms-- 会員状態テーブル
    ON  ms.status_id = msh.status_id
WHERE
    m.name = 'user123'
ORDER BY
    msh.created_at DESC-- 状態変更日時でソート
LIMIT(1)
;
```

しかし、VIEW を使用することで対処可能。

```sql
CREATE VIEW user_latest_status AS
SELECT
    m.name AS member_name,
    ms.name AS status_name,
    msh.created_at AS status_changed_at
FROM
    members m
    INNER JOIN
        member_status_hisyory msh -- 会員状態履歴テーブル
    ON  m.id = msh.member_id
    INNER JOIN
        member_status ms -- 会員状態テーブル
    ON  ms.status_id = msh.status_id
ORDER BY
    msh.created_at DESC; -- 状態変更日時でソート
```

## 状態に依存するカラムが存在する場合

会員の「強制退会」を考える。
この「強制退会」には、状態に加え「強制退会理由」も付与したい。

状態は `member_status` テーブルに対し、新規レコードを追加すれば良い（`name = banned`）。
「強制退会理由」のデータはどこに保存すれば良いか？

状態に依存するレコードを集めたテーブルを作成し、リレーションさせる。

![](https://storage.googleapis.com/zenn-user-upload/b6e3fc896d95-20240914.png)

テーブルの数は多くなるが、**nullabe なカラムを防ぐことができる**。

## 参考リンク

https://qiita.com/n_yamadamadamada/items/e844d33db2fe47376c1f

https://zenn.dev/rsugi/articles/8a939d7bd2f60a#%E8%A7%A3%E6%B1%BA%E6%A1%88
