---
title: "論理設計のバッドノウハウ"
---

- システムの品質を決めるのは設計
- プログラミングは、設計をプログラミング言語に翻訳する作業
- プログラミング自身がシステムの品質を左右することは、稀
- しかし、世の中には不適切な論理設計が多く存在する
- 論理設計のバッドノウハウを知ることは大事

## 非スカラ値（第 1 正規形未満）

第 1 正規形の定義は
**一つのセルの中には一つの値しか含まない**

**社員テーブル**
| 会社コード | 会社名 | 社員 ID | 社員名　 | 年齢 | 部署コード | 部署名 |
| ---------- | ------ | ------- | -------- | ---- | ---------- | ------ |
| C0001 | A 商事 | 000A | 中島 | 40 | D01 | 開発 |
| C0001 | A 商事 | 000B | 藤本 | 32 | D02 | 人事 |
| C0001 | A 商事 | 001F | 三島 | 50 | D03 | 営業 |
| C0002 | B 科学 | 000A | 斉藤 | 47 | D03 | 営業 |
| C0002 | B 科学 | 009F | 田島 | 25 | D01 | 開発 |
| C0002 | B 科学 | 010A | 渋谷 | 33 | D04 | 総務 |

上記のように、一つのセルに一つだけの値が含まれているとき、その値を「**スカラ値（scalar value）**」と呼ぶ。
scalar は「単一の」という意味の英単語。

### 配列型による非スカラ値

**`扶養者`テーブル**
| 社員 ID | 社員名 | 子 |
| ------- | ------ | -------------- |
| 000A | 加藤 | 達夫, 信二 |
| 000B | 藤本 | |
| 001F | 三島 | 敦, 陽子, 清美 |

- この表は、`子` 列が非スカラ値
- そのため、これは RDB における「テーブル」ではない
- しかし、SQL には「**配列型**」が存在する
- そのため、テーブルの一つの列を配列として扱うことができる
- つまり、**非スカラ値を含むテーブルを作ることができる**

テーブル作成の DDL（テーブルの物理定義 SQL）は以下の通り。

```sql
CREATE TABLE huyosha (
  shain_id varchar(4),
  shain_mei varchar(20),

  kodomo varchar(20)[], ← 配列型の宣言
  PRIMARY KEY(shain_id)
);
```

レコードの INSERT 文は以下の通り。

```sql
INSERT INTO huyosha VALUES ("000A", "加藤", "{達夫, 信二}");
INSERT INTO huyosha VALUES ("000B", "藤本", NULL);
INSERT INTO huyosha VALUES ("001F", "三島", "{敦, 陽子, 清美}");
```

- プログラミング言語は配列を扱うことができる
- それに合わせる形で RDB も配列を扱えるようになった
  - DB とアプリケーションとの間でデータ受け渡しに齟齬ができてしまうのを防ぐため

![](https://storage.googleapis.com/zenn-user-upload/e1b204c8b650-20231026.png)

- しかし、RDB で配列を扱うのはバッドノウハウ
- 配列を扱う機能は存在するが、一般的には普及してない
- DB 側だけが配列型に対応しても、アプリケーションやミドルウェアも対応しなければ意味がない
- よって、現状は安易に配列型を使用せず、第 1 正規形の確保を優先する
- 配列型を採用する場合は、DB 内部に閉じた設計だけでなく、アプリケーションやミドルウェアとの整合性を考慮しなければならない

:::message
**配列型は利用しない。**
**第 1 正規形を守る。**
:::

### スカラ値の基準は何か？

- スカラ値の基準は、第一正規形に関連して、テーブル内の値が原子的であることを指す
- 原子的な値は、分解できない単一の値で構成されている
- 例えば、会社名や年齢など、分解すると意味が失われるような値はスカラ値と見なされる
- ただし、一部の値は論理的に分解可能で、データベース設計は要件に依存する
- 例えば、人名やメールアドレスは、分解して保存することができる
- 著者の見解では、情報は可能な限り分解し、原子的な形でデータを保持すべきであり、後で必要に応じて結合することが容易
- 結合された情報を後から分解することは難しい場合があるため、分解を推奨する

:::message
**スカラ値の基準は、データを原子的な単一の値として保持し、必要に応じて分解や結合することができるようにする。**
:::

## ダブルミーニング

| 年度 | 学生名 | 身長 | 体重 or 年齢 |
| ---- | ------ | ---- | ------------ |
| 2001 | 加藤   | 170  | 62           |
| 2002 | 藤本   | 165  | 55           |
| 2003 | 三島   | 180  | 18           |

- 上記テーブルの`体重 or 年齢` 列のようなカラムを用意してはいけない
- 同一のカラムが複数の意味をもってはいけない

:::message
列は変数ではない。
一度意味を決めたら変更不可。
:::

## 単一参照デーブル

ダブルネーミングの概念がテーブル全体に広がったもの。
以下の第 3 正規化まで進んだテーブル群を例に考える。

![](https://storage.googleapis.com/zenn-user-upload/b28c26655eb4-20231028.png)

`会社` テーブルと `部署` テーブルはデータの構造が同じであるため、**一つのテーブルにまとめることが可能**。

以下のように、同じ構造をもつエンティティを同一のデーブルとして定義したものを**単一参照テーブル**と呼ぶ。

![](https://storage.googleapis.com/zenn-user-upload/a010d1ed20ab-20231028.png)

### メリット

- マスタテーブルの数が減るため、ER 図やスキーマがシンプルになる
- コード検索の SQL を共通化できる

### デメリット

- `コードタイプ`、`コード値`、`コード内容` の各列とも、必要とされる列長はコード体系によって異なるため、余裕を見てかなり大きめの可変長文字列型で宣言する必要がある
- 一つのテーブルにレコードを集約するため、コード体系の種類と大きさによっては、レコード数が多くなり、検索のパフォーマンスが悪化する
- コード検索の SQL 内でコードタイプやコード値を間違えて指定してもエラーになることがないため、バグに気づきにくい
- ER 図がスッキリするとは言っても、ER モデルとしては正確さを欠いており、逆に ER 図の可読性を下げる

## テーブルの分割

- テーブル分割は一般的にパフォーマンス向上を目的として実施することが多い
- テーブル分割手法は何種類か存在する
- 分割手法の中にはバットノウハウも存在するため、注意が必要

### 水平分割

![](https://storage.googleapis.com/zenn-user-upload/18b65edd39d2-20231028.png)

以下のテーブルを例に考える。

**売り上げテーブル**
| 年度 | 会社コード | 売り上げ（億円） |
| ---- | ------ | ---- |
| 2001 | C0001 | 50 |
| 2001 | C0002 | 52 |
| 2001 | C0003 | 55 |
| 2001 | C0004 | 46 |
| .... | .... | .... |
| 2001 | C0004 | 50 |
| 2002 | C0001 | 52 |
| 2002 | C0002 | 55 |
| 2002 | C0004 | 60 |
| 2002 | C0001 | 47 |
| .... | .... | .... |
| 2002 | C0004 | 54 |
| 2003 | C0001 | 46 |
| 2003 | C0002 | 52 |
| 2003 | C0003 | 44 |
| 2003 | C0004 | 60 |
| .... | .... | .... |
| 2003 | C0004 | 59 |

- このテーブルには数百万〜数十億という数のレコードが含まれる
- そのため、SQL のパフォーマンス悪化が懸念される
- **SQL のパフォーマンス悪化が起きる最大の原因は、ストレージ（ディスク）に対する I/O コストの増大**
- アクセスするデータ量を減らすことが、パフォーマンス改善の手段
- 改善案の一つは、SQL がアクセスするテーブルのサイズを小さくする

例えば、SQL が常に 1 年ごとにしか `売り上げ` テーブルにアクセスしない場合、以下のように年度ごとにテーブルを分割することでパフォーマンスを改善できる。

**売り上げ（2001）テーブル**
| 年度 | 会社コード | 売り上げ（億円） |
| ---- | ------ | ---- |
| 2001 | C0001 | 50 |
| 2001 | C0002 | 52 |
| 2001 | C0003 | 55 |
| 2001 | C0004 | 46 |
| .... | .... | .... |
| 2001 | C0004 | 50 |

**売り上げ（2002）テーブル**
| 年度 | 会社コード | 売り上げ（億円） |
| ---- | ------ | ---- |
| 2002 | C0001 | 52 |
| 2002 | C0002 | 55 |
| 2002 | C0004 | 60 |
| 2002 | C0001 | 47 |
| .... | .... | .... |
| 2002 | C0004 | 54 |

**売り上げ（2003）テーブル**
| 年度 | 会社コード | 売り上げ（億円） |
| ---- | ------ | ---- |
| 2003 | C0001 | 46 |
| 2003 | C0002 | 52 |
| 2003 | C0003 | 44 |
| 2003 | C0004 | 60 |
| .... | .... | .... |
| 2003 | C0004 | 59 |

しかし、この分割は以下のような重大なデメリットがあるため、RDB では原則禁止。

#### 分割する意味的な理由がない

- 水平分割する理由は、正規化の理論からは存在しない
- 純粋にパフォーマンスという物理レベルの要請によるもの
- よって、安易に実施すべきでない

#### 拡張性に乏しい

- 上記の例では、水平分割によりパフォーマンス改善に効果を発揮するのは、「前年度のデータを総なめで検索することはない」という前提が成立する場合のみ
- その前提が常に成立するかどうかは保証の限りではない
- また、この分割を採用する場合、2004 年以降のデータもテーブルを新たに用意する必要があるため、テーブル数が増えていく

#### 他の代替手段がある

- 多くの DBMS が「パーティション」という機能を持つ
- パーティションを用いることで、テーブルを分割することなく、パーティションキー（`売り上げ` テーブルの場合は `年度`）を軸として物理的に格納領域を分離することが可能
- これにより、SQL がアクセスするデータ量を 1/n に減らせる（n はパーティションの数）

:::details パーティション vs インデックス

- パーティションはインデックスよりもカーディナリティが小さく、かつ値の変更が少ない列をキーにして利用する
- 「年」や「都道府県」など、カーディナリティが十~数十であるキーが対象
- インデックスは、もう少しカーディナリティが高くないと効果が得られない

:::

### 垂直分割

![](https://storage.googleapis.com/zenn-user-upload/2882cb5a15c6-20231028.png)

以下のテーブルを例に考える。
**社員テーブル**
| 会社コード | 社員 ID | 社員名 | 年齢 | 部署コード |
| ---- | ------ | ---- | -- | -- |
| C0001 | 000A | 加藤 | 40 | D01 |
| C0001 | 000B | 藤本 | 32 | D02 |
| C0001 | 001F | 三島 | 50 | D03 |
| C0002 | 000A | 斉藤 | 47 | D03 |
| C0002 | 009F | 田島 | 25 | D01 |
| C0002 | 010A | 渋谷 | 33 | D04 |

- 現在、このテーブルに対する検索 SQL に遅延が発生しており、改善の必要がある
- 検索で利用する列は、常に `会社コード`、`社員ID`、`年齢`
- このとき、以下のようにテーブルを分割することで SQL 文がアクセスするデータ量を減らせる

**社員 1 テーブル**
| 会社コード | 社員 ID | 年齢 |
| ---- | ------ | ---- |
| C0001 | 000A | 40 |
| C0001 | 000B | 32 |
| C0001 | 001F | 50 |
| C0002 | 000A | 47 |
| C0002 | 009F | 25 |
| C0002 | 010A | 33 |

**社員 2 テーブル**
| 会社コード | 社員 ID | 社員名 | 部署コード |
| ---- | ------ | ---- | -- |
| C0001 | 000A | 加藤 | D01 |
| C0001 | 000B | 藤本 | D02 |
| C0001 | 001F | 三島 | D03 |
| C0002 | 000A | 斉藤 | D03 |
| C0002 | 009F | 田島 | D01 |
| C0002 | 010A | 渋谷 | D04 |

- 検索に必要な列だけに絞った `社員1` テーブルを検索対象とすることで、SQL のパフォーマンス改善が可能になる
  - （ボトルネックがストレージの I/O コストだった場合）
- この分割は正規化ではない
- 無損失分解ではあるので、結合によって元の `社員` テーブルを復元できる
- しかし、垂直分割にも「**分割することが論理的な意味を持たない**」というデメリットがあるため、**原則利用するばきでない**
- 垂直分割は「**集約**」で代替することが可能

### 集約

- テーブル分割の代替案に位置付けられる手法
- 以下の 2 種類が存在する
  - 列の絞り込み
  - サマリテーブル

#### 列の絞り込み

- 保持する列を絞ったテーブルを作成する
- 垂直分割に対する代替案に相当する
- 検索時、頻繁に参照される列だけを持った新たなテーブルを作成する
- オリジナルのテーブルは残すため、分割ではない

![](https://storage.googleapis.com/zenn-user-upload/7173d099f0fd-20231028.png)

- このようにして作成される小規模なテーブルを、**データマート（マート）**と呼ぶ
- マートはオリジナルのデータを破壊せずにパフォーマンスを向上させることができる
- 実際の開発にもよく利用される
- しかし、マートばかり作成されてしまい、ストレージの容量を圧迫するケースもある
- また、**データ同期**の問題もある
- 更新タイミングが早いほど、データ整合性の精度が高く、好ましいが、更新処理の負荷が上がる
- 多くの場合、マートの更新は 1 日 1 回〜数回程度の頻度でバッチ更新される
- 結局は、要件に合わせて意思決定するのが大事

#### サマリテーブル

- 集約関数によってレコードを集約した状態で保持すること

![](https://storage.googleapis.com/zenn-user-upload/e80bbe3b3511-20231028.png)

- `社員平均年齢` テーブルのサイズは、行列ともに元の `社員` テーブルより小さくなる
- アクセスするときの I/O コストを大きく削減できる
- オリジナルのテーブルを変更することもない
- しかし、データ同期の問題はある

## 不適切なキー

以下のキーについては、データ型の定義に注意する

- **主キー、外部キーなどデータベースの機能で設定されるもの**
- **テーブルの結合条件で使用される列（結合キー）**

この２つの用途で使用される列では、データ型に **可変長文字列（VARCHAR）** を使用してはいけない。
理由は、

- 可変長文字列にはキーが満たすべき条件である**不変性**を備えていない
- 固定長文字列と混同する可能性がある

## ダブルマスタ

同じ役割を果たすはずのマスタテーブルが２つ存在するようなケース。

**顧客マスタ A**
| 顧客コード | 顧客名 |
| -------| ------|
| C001 | 山田太郎 |
| C002 | 中島義人 |
| C003 | 新藤啓太 |
| C004 | 中村佳織 |

**顧客マスタ B**
| 顧客コード | 顧客名 |
| -------| ------|
| C001 | 山田太郎 |
| C002 | 中島義人 |
| C003 | 新藤啓太 |
| C004 | 小嶋雅夫 |

- `顧客マスタ A` と `顧客マスタ B` は、同じ顧客の情報も重複して持っている
- 片方のマスタにしかない顧客の情報もある
- 顧客全員の情報を得るには 2 つのマスタを結合しなければならない

### ダブルマスタはなぜ生じるのか？

もともと別のシステムで利用されていたマスタ同士が、システム統合によって同じドメインに存在するようになった場合に同じような役割をもつテーブルが生まれる。
