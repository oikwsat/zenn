---
title: "正規化"
---

- データの整合性と効率性を向上させるための手法
- データベース内のテーブルを効果的に構造化し、データの重複や不整合を最小限に抑える
- 正規化により、データベースの管理と操作が容易になり、データの信頼性が向上する
- 正規化されたものは**正規形**と呼ぶ

## 目的

- データの**一貫性**と**整合性**を維持する
- 重複データを排除する
- データの効率的な検索と更新を可能にする
- データの柔軟性を向上させる

## 正規化の手法

![](https://storage.googleapis.com/zenn-user-upload/3908552a2b66-20230909.png)

- 正規化のステップとしては、第 1 正規化、第 2 正規化、第３正規化、....
- 段階を踏んでいく毎に細分化されていく
- 基本的には第３正規化までやる

## 関数従属性

- ある属性 X を決めると、他の属性 Y の値が一意に決まる場合、「Y は X に関数従属している」
- X -> Y と表現する
- X を**決定項**、Y を**被決定項**と呼ぶ

![](https://storage.googleapis.com/zenn-user-upload/966c236385ed-20230909.jpg)

次の例のように決定項や被決定項が複数の属性の組合せになる場合もある。

![](https://storage.googleapis.com/zenn-user-upload/88ee09a85380-20230909.jpg)

実は正規化とは、テーブルすべての列が**関数従属性**を満たすように整理していくことである。

## 部分関数従属

以下のように候補キーの一部に関数従属している状態を「部分関数従属している」という。

![](https://storage.googleapis.com/zenn-user-upload/792178ab9f39-20230909.png)

## 完全関数従属

- 完全関数従属性は、属性が他の属性に関数的に従属しており、その属性が複合キーの一部でない場合に関連します。
- つまり、特定の属性が他の属性に関数的に従属し、その属性が他の属性集合全体に従属しているということです。
- 例えば、社員番号と部署コードから社員の名前が特定でき、かつ社員番号や部署コード単独では名前を特定できない場合、社員番号と部署コードは名前に完全関数的に従属しています。

## 推移的関数従属

A が B に関数的に従属し、B が C に関数的に従属する場合、A が C に対して推移的関数従属していると言いう。

![](https://storage.googleapis.com/zenn-user-upload/403df4d9525e-20230909.png)

## 非正規形

以下の伝票票を元に、正規化を行う。

![](https://storage.googleapis.com/zenn-user-upload/7a7702681253-20230909.png)

この受注伝票 1 枚が 1 件のレコードに相当するとし、並べてみる。

![](https://storage.googleapis.com/zenn-user-upload/956242a2d8a8-20230909.png)

上記のように、1 行の中に複数の繰り返し項目が存在するような表は**非正規形**と呼ぶ。
これでは、各レコードの長さがバラバラで、綺麗な 2 次元の表になってない。
リレーショナルデータベースでは、レコードとしてデータを追加していく操作には適しているが、横方向へ増える非正規形の表は管理することができないため、正規化をしていく必要がある。

## 第 1 正規形

### 定義

**一つのセルの中には一つの値しか含まない**

![](https://storage.googleapis.com/zenn-user-upload/edf5cacb629f-20230910.png)

上記のように、一つのセルに一つだけの値が含まれているとき、その値を「**スカラ値（scalar value）**」と呼ぶ。
scalar は「単一の」という意味の英単語。

### 第１正規形を作成する

以下の非正規形に対して第１正規化を行う。

![](https://storage.googleapis.com/zenn-user-upload/37d9a109c5e4-20230910.png)

上記では、`子` 属性に複数の値が入っている。
これは、「一つのセルの中には一つの値しか含まない」という状態に反しており、RDB では重大な規則違反になる。

そのため、下記のように正規化を行う。

![](https://storage.googleapis.com/zenn-user-upload/ea1c23bd3e3d-20230910.png)

上記は、`子` の数だけレコードを増やすことにより「一つのセルの中には一つの値しか含まない」という条件を満たしている。

しかし、上記のテーブルには以下 2 つの問題がある。

- 主キーを決められない
- テーブルの意味やレコードの単位をすぐに理解できない

#### 主キーを決められない

任意の 1 レコードを特定しようとすると、`{社員ID, 社員名, 子}` の全ての属性を指定する必要がある。
`{社員ID, 社員名}` だけだと、「`社員ID` = `00A`」「`社員名` = `加藤`」のように指定した場合に、2 レコードが該当してしまう。
また、`{社員ID, 社員名, 子}` を主キーとした場合でも、`子` は `NULL` になる可能性がある。
主キーには `NULL` が含むのを許可していない。

#### テーブルの意味やレコードの単位をすぐに理解できない

先ほどのテーブルでは意味的に「社員」と「扶養者」というエンティティの情報を含んでしまっており、テーブルの意味やレコードの単位をすぐに理解できない。

#### 解決策

上記 2 つの問題を解決するには、以下のようにテーブルを分ける必要がある。

![](https://storage.googleapis.com/zenn-user-upload/08fb58190eee-20230910.png)

### なぜ一つのセルに複数のセルに値を入れてはダメなのか？

**セルに複数の値を許せば、主キーが各列の値を一意に決定できないから**

![](https://storage.googleapis.com/zenn-user-upload/37d9a109c5e4-20230910.png)

上記の非正規形では、主キーである `社員ID` が `子` を一意に特定することができない。
上記では `{社員ID}` -> `{社員名}` という関数従属が成立している。
しかし、`{社員ID}` -> `{子}` という関数従属は不成立となっている。
