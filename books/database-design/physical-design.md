---
title: "内部スキーマと物理設計"
---

## 物理設計のステップ

![](https://storage.googleapis.com/zenn-user-upload/98ff52756660-20230916.png)

## テーブル定義

- 論理設計で定義された概念スキーマをもとに、それを DBMS 内部に格納するための「テーブル」単位に変換する
- このフェーズで作られるモデルを**物理モデル**と呼ぶ

## インデックス定義

- インデックスは、データの高速検索とアクセスを可能にするデータ構造の一つ
- データベース内のテーブルやビューの特定の列に対して、効率的なデータの格納方法と検索方法を提供する
- インデックスがパフォーマンスにおいて重要な役割を果たす

:::message
インデックスを理解するには、ちょうど本の索引をイメージすると良いでしょう。特定の単語がどのページに存在するか見つけ出したいとき、1 ページ目から順にページをめくっていくのは、ページ数が多くなればなるほど非効率で時間がかかります。本の索引は、この手間を省略して、ある単語が何ページ目に書かれているかをダイレクトに示してくれるので、直接該当ページへ飛ぶことを可能にします。
:::

## ハードウェアのサイジング

- 「サイジング」には 2 種類ある
  - キャパシティ
  - パフォーマンス

### キャパシティのサイジング

- 「キャパシティ」はデータの規模
- システムで利用するデータサイズを見積もり、それに十分な容量の記憶装置（ストレージ）を選定する

キャパシティのサイジングには以下の情報が必要となる。

#### システムで利用するデータ量

- DB 内に格納するデータ量は、物理的なテーブルおよびインデックス定義の後に算出される
- 従って、論理設計の後に行う必要がある
- データ量は、DB 内に格納するテーブル以外にも、テキストや画像、HTML といった様々なものを考慮する必要がある

#### サービス終了時

- 基本的に、データ量はシステム運用開始から増加していく
- システム運用終了時にデータ量がどの程度増えるかを予測しておく必要がある

![](https://storage.googleapis.com/zenn-user-upload/768b91be2bf3-20230916.png)

- 初めからデータの量の増加を予測するのは困難な場合、以下のアプローチをとる
  1. 安全率を大きくとって、余裕を持たせたサイジングを行う
  2. 容量が不足した場合に備えて、簡単に記憶装置を追加できるような構成にする

### パフォーマンスのサイジング

- サイズを測る対象は CPU やメモリ
- 十分な性能を発揮できるだけのスペックの CPU やメモリを持ったサーバを選定する

パフォーマンスのサイジングには以下の指標が必要となる。

#### 処理時間

- 特定の処理が何秒以内に終了するのか？
- どれだけ速く処理できるか？

#### スループット

- 単位時間当たりにどれだけの処理をこなせるか？
- どれだけたくさん処理できるか？
- 「一秒当たりの仕事量」を示す**TPS**を使用する

#### リソース使用量の基礎数値

- サイジングの見積もりは難しい...
- 見積もりといっても、その根拠となる基礎数値が欲しい...
- そのため、以下の方法で基礎数値を得る
  1. 類似の稼働中システムのデータを流用する
  2. 開発の初期段階でプロトタイプシステムを構築し、性能検証を実施する

## ストレージの冗長構成

### ストレージとは？

- DB のデータを保持する媒体
- 一般的には HDD（ハードディスクドライブ）を使用する
- DB に保管されているデータは非常に重要度が高いデータであるため、耐障害性を上げる必要がある
- そのために利用される技術が**RAID**

### RAID とは？

- 複数ディスクを束ねて、**仮想敵な一つのストレージとする技術**

### RAID の基本的な考え方

- 同じデータを複数ディスクに書き込むことによって冗長化することで、安全性を高める

::: details 冗長化とは？

- 同じデータが重複して存在する状態

:::

### RAID のメリット

- 安全性の向上
- 性能の向上

### RAID 構築の流れ

- データベースの物理設計においては、RAID について以下を考える必要がある

  - 当該データに求めるのは信頼性か？性能か？
  - どのレベルの RAID を採用するか？
  - 何本のディスクで RAID を構成するか？

- 最初の問いが最も重要
- これにより、RAID のレベルやディスク本数が決まる

### RAID0（ストライビング）

![](https://storage.googleapis.com/zenn-user-upload/752c28e5ec98-20230916.png =500x)

- 複数のディスクにデータを分散する
- 冗長性は全くない
- ディスクのうち一本でも故障すると破綻する
  - そのため、**「RAID として欠陥がある」** という意見もある
- ディスクを分散することにより、**ディスク I/O の性能がかなり高い**

### RAID1（ミラーリング）

![](https://storage.googleapis.com/zenn-user-upload/9a07f2ad588d-20230916.png =500x)

- 2 本のディスクに全く同じデータを書き込む
- **信頼性が高くなる**
- 性能は 1 本の時と変わらない
- ディスクの使用効率もあまり良くない

### RAID5（バリティ分散）

- 最低 3 本以上のディスクが必要になる
- データとともに**パリティ**と呼ばれる誤り符号訂正符号を分散して格納する
- ディスクが壊れても、パリティから実データを復元することが可能
- 1 本までならどのディスクが壊れてもデータを復元できる
- 2 本ディスクが同時に壊れると、データが失われる
- データを分散することができるため、**ディスク I/O の性能の向上**も期待できる
- **ディスク本数が増えるほど読み出し性能が向上する**

![](https://storage.googleapis.com/zenn-user-upload/f0148cbdef89-20230917.png)

### RAID10（RAID1 + 0）

- RAID1 と RAID0 を組み合わせたもの
- 最初に RAID1 のグループを作り、さらにその中で RAID0 を作る
- RAID0 の**速度**と、RAID1 の**安全性**のいいとこ取り
- しかし、最低 4 本のディスクが必要になるため、**コストが高くなる**

![](https://storage.googleapis.com/zenn-user-upload/620aaff69121-20230917.png)

### どの RAID パターンを採用するか？

- 第一候補は**RAID10**
  - ストライピングとミラーリングのいいとこどり方式
  - しかし、最低構成に必要なディスクが多く最もコストが高い
  - そのため、予算に余裕がないと採用できない
- 第二候補は**RAID5**
  - 信頼性と性能を両歩ともある程度向上させられる
- 第三候補は**RAID1**
  - 信頼性は強固なので、重要なデータを格納するデータベースに相応しい
  - しかし、パフォーマンス向上が期待できないのが難点
- **RAID0**は論外
  - 耐障害性が低いため、ディスク 1 本が壊れた瞬間に障害発生

## ファイルの物理配置

- ストレージの冗長構成が決まったら、DB のファイルをどのディスク（RAID グループ）に配置するかを決定する
- 最近の DBMS では自動化が進んでおり、ファイルの配置を行ってくれる
- DB に格納されるファイルは、用途別に以下の 5 種類に大別できる
  1. データファイル
  2. インデックスファイル
  3. システムファイル
  4. 一時ファイル
  5. ログファイル
- このうち、開発者が意識するのは、**データファイル**と**インデックスファイル**

### データファイル

- ユーザが DB に格納するデータを保持するためのファイル
- SQL を通じで参照及び更新を行うファイル

### インデックスファイル

- テーブルに作成されたインデックスが格納されるファイル
- DBMS ではテーブルとインデックスは普通異なるファイルとして管理される

### システムファイル

- DBMS の内部管理用に使われるデータを格納する
- 基本的に業務アプリケーションやユーザがアクセスすることはない

### 一時ファイル

- DBMS 内部での一時的なデータを格納するために使用される
- 一時的なデータとは？
  - SQL で使われたサブクエリを展開したデータ
  - `GROUP BY` や `DISTINCT` を利用したときのソートデータ
- 一時データは、処理が終了すれば削除される

### ログファイル

- テーブルに対するデータ変更の一時格納ファイル

### 各ファイルの特徴

![](https://storage.googleapis.com/zenn-user-upload/58e3f41b0e83-20230917.png)

### ファイルの配置構成

- 物理配置で最も重要なのは、**サイズ**と**性能**
- ディスク I/O の量が多くなるのは
  - データファイル
  - インデックスファイル
  - 一時ファイル
- 従って、これらのファイルは独立したディスクに配置することが望ましい
- 以上から、最も望ましいファイル配置は、すべてのファイルを異なるディスクに配置する
  ![](https://storage.googleapis.com/zenn-user-upload/0b0d0a8b7ff8-20230917.png)
- しかし、高コストになる。
- そのため、性能的に分散優先度の高いファイルを分離し、I/O コストの低いファイルを一つにまとめる
  ![](https://storage.googleapis.com/zenn-user-upload/ace1534a0543-20230917.png)
